[{"content":"new expression 分配内存-调用构造函数-返回指针\nThe new operator is an operator which denotes a request for memory allocation on the Heap. If sufficient memory is available, new operator initializes the memory and returns the address of the newly allocated and initialized memory to the pointer variable. When you create an object of class using new keyword(normal new).\nThe memory for the object is allocated using operator new from heap. The constructor of the class is invoked to properly initialize this memory. operator new 只分配内存-返回指针/抛出异常\nOperator new is a function that allocates raw memory and conceptually a bit similar to malloc().\nIt is the mechanism of overriding the default heap allocation logic. It doesn’t initializes the memory i.e constructor is not called. However, after our overloaded new returns, the compiler then automatically calls the constructor also as applicable. It’s also possible to overload operator new either globally, or for a specific class New operator vs operator new Operator vs function: new is an operator as well as a keyword whereas operator new is only a function. New calls “Operator new”: “new operator” calls “operator new()” , like the way + operator calls operator +() “Operator new” can be Overloaded: Operator new can be overloaded just like functions allowing us to do customized tasks. Memory allocation: ‘new expression’ call ‘operator new’ to allocate raw memory, then call constructor. References ","date":"2024-09-30T09:52:09+08:00","permalink":"https://MasonCodingHere.github.io/p/things-about-new/","title":"C++ new那些事儿"},{"content":"前言 本文待完善。\n整体思路 使用Hugo作为博客框架，在本地编写Markdown文件，构成博客站点源码库。将源码库上传至GitHub仓库MasonHugoBlog，并设置GitHub Action，由GitHub Action运行hugo命令生成博客HTML文件并上传至MasonCodingHere.github.io，最终由GitHub Pages完成部署。\n所以需要两个GitHub仓库。\nMasonHugoBlog：用于存储站点源码。 MasonCodingHere.github.io：用于存储生成的HTML文件。 Hugo安装与配置 参考Hugo官方文档，根据操作系统选择安装方式。本文以macOS为例。\n前提 Hugo依赖Git和Go，所以要先安装这两个。\n不展开讲了。\n安装hugo 本文采用Homebrew的安装方式\n1 brew install hugo 安装结束，执行以下命令，看到版本号说明安装成功。\n1 hugo version 新建站点 在你希望的位置执行下面的命令，新建一个Hugo站点。\n1 hugo new site MasonHugoBlog 这样会出现一个名为MasonHugoBlog的文件夹，这就是博客源码。\n选择主题 在官方主题库选择一个主题，当然也可以去GitHub找官方主题库里没有的主题。本文选择Stack主题。\n本文选择Git Submodule的方式安装。\n1 2 3 cd MasonHugoblog git init git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack 这样theme文件夹下就会出现该主题。我想让我的博客跟Stack主题提供的Demo站点一样，所以做了一下事情。\n把MasonHugoblog/themes/Hugo-theme-stack/exampleSite/content/下的内容复制到MasonHugoblog/content/。 删除MasonHugoblog/hugo.toml，把MasonHugoblog/themes/Hugo-theme-stack/Hugo.yaml复制到MasonHugoblog/。 这样执行以下命令，在本地预览，发现已经跟Demo一致。\n1 hugo server -D 配置博客 各种个性化配置，包括该博客名称、换头像、改链接、去除自己不需要的多语言支持等等，在hugo.yaml中配置。\n删除默认博文、删除默认分类和标签、修改博文默认模版等等。\n不展开说了。\nGitHub Actions Push to GitHub 接下来就是把整个文件夹推到GitHub，在GitHub新建一个仓库MasonHugoBlog。把本地的MasonHugoBlog文件夹推到这个仓库。不细说了。\n之后，因为我们以后写文章、更新博客，都是要推这个文件夹，所以写一个脚本更方便，在MasonHugoBlog下新建一个名为deploy.sh的脚本文件，把以下内容复制粘贴过去。这样以后写完md文件，直接执行./deploy.sh就完成部署了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #!/bin/bash # Check if the directory /public exists if [ -d \u0026#34;./public\u0026#34; ]; then # If it exists, delete the directory rm -rf ./public echo \u0026#34;./public directory has been deleted.\u0026#34; else # If it doesn\u0026#39;t exist, print a message echo \u0026#34;./public directory does not exist.\u0026#34; fi # Check if a commit message was provided as an argument if [ -z \u0026#34;$1\u0026#34; ]; then # If no commit message is provided, use the current date and time COMMIT_MSG=\u0026#34;Update at $(date)\u0026#34; else # Use the provided commit message COMMIT_MSG=\u0026#34;$1\u0026#34; fi # Add all changes git add . # Commit changes with the provided message git commit -m \u0026#34;$COMMIT_MSG\u0026#34; # Push changes to the \u0026#39;main\u0026#39; branch git push origin main # Print a success message echo \u0026#34;Changes have been pushed to GitHub successfully!\u0026#34; 因为我们想这个库只保存源码，所以生成的静态HTML文件我们不要，所以在上传之前先检测有无/public文件夹，有的话删掉再上传。\nDeploy Key 在本地用sshkeygen生成一对key\n公钥给MasonCodingHere.github.io的Deploy key\n私钥给MasonHugoBlog的Actions的secrets。\nMasonHugoBlog的Workflow permissions改为Read and write permissions\nGitHub Actions 给MasonHugoBlog添加Actions\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 name: Deploy Hugo to GitHub Pages on: push: branches: - main # Trigger deployment when changes are pushed to the main branch jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout the repository uses: actions/checkout@v2 with: submodules: true - name: Set up Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.134.2\u0026#39; extended: true - name: Build the website run: hugo - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.DEPLOY_KEY }} publish_dir: ./public # This is the directory where Hugo generates static files external_repository: MasonCodingHere/MasonCodingHere.github.io publish_branch: main GitHub图床 每个repo有1G的大小限制，如果把图片也传到博客仓库，很快就会满。\n在GitHub新建一个图床库PicsBed_1\n生成一个Token，选public_repo\n安装PicGo，设置Token。\n为PicsBed_1添加Actions如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 name: Update README with Directory Structure on: push: branches: - main jobs: update-readme: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v2 - name: Generate directory structure run: | echo \u0026#34;# Directory Structure\u0026#34; \u0026gt; structure.txt echo \u0026#34;\\`\\`\\`\u0026#34; \u0026gt;\u0026gt; structure.txt tree -I \u0026#34;.git|node_modules|structure.txt\u0026#34; \u0026gt;\u0026gt; structure.txt echo \u0026#34;\\`\\`\\`\u0026#34; \u0026gt;\u0026gt; structure.txt - name: Update README run: | cat structure.txt \u0026gt; README.md - name: Commit changes run: | git config --local user.name \u0026#34;GitHub Action\u0026#34; git config --local user.email \u0026#34;action@github.com\u0026#34; git add README.md git commit -m \u0026#34;Update directory structure in README\u0026#34; git push env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} References Hugo官方文档 Stack主题官方网站 Stack主题官方GitHub仓库 图片上传工具PicGo官网 图片上传工具PicGo官方GitHub仓库 ","date":"2024-09-20T15:18:02+08:00","permalink":"https://MasonCodingHere.github.io/p/build-your-blog/","title":"Hugo + GitHub Pages搭建个人博客"},{"content":"前言 大家都知道，像Google、Twitter这类的海外网站在中国大陆是无法直接访问的。大家还知道，连上VPN就可以访问这些网站了。至于其中的细节，大多数人就不知道了，确实也没必要知道。但是有一点我们要明白，VPN能够起到效果的重要原因是GFW没有封锁一切海外网站。正是由于这个原因，我们才能有空子可钻。\n技术上讲，VPN≠翻墙。不过在大陆VPN已经成为翻墙的代名词，这里就不咬文嚼字了。\n在互联网中，IP地址是我们的“身份证”。这些被禁的海外网站也有自己的IP地址，可惜被墙了，所以我们无法直接访问。还存在一些IP地址，没有被墙，我们可以访问。一系列的翻墙技术正是建立在这个基础上。\n假设有这样一个IP地址A，A没有被GFW墙掉，并且A作为互联网的一员，可以访问那些被墙的网站。我们可以把要访问Google的请求发给A，由A帮我们访问，再把结果发给我们，这就是代理的原理，也是一系列翻墙技术得以实现的基础。\n购买VPS 我们需要一个没有被墙的IP地址，购买一台海外VPS可以满足这个需求。VPS其实就是一台位于海外的云服务器。\n有很多VPS厂商，比如BandWagon、Vultr、CloudCone等等，本文以Vultr为例，其他的厂商也大同小异。\n注册并登陆Vultr，点击右上角的Deploy按钮按以下步骤部署一台VPS。\n选择VPS类型和位置 类型选Shared CPU即可。\n位置看自己需求，这里以美国Los Angeles为例。\n选择系统镜像 选一个操作系统，服务器嘛，自然是要选Linux，推荐选择Debian，比较稳定。\n选择Plan 根据需求，选择一个配置，配置越高越贵。这里选择最便宜的5$/month的Plan。\n其他设置 去掉Auto Backups，费钱。\n去掉IPv6，不需要。\n这里可以把SSH key上传一下，把本地电脑~/.ssh/的公钥传到Vultr，这样等部署完可以直接密钥登陆，不用输密码，方便很多。\n在Server Hostname设置一下主机名，自己起个名即可，本文以Test为例。\n下单 这样就配好了，确认一下数量和价格，点击Deploy Now就开始部署了。\n部署过程或许需要几分钟，耐心等待一下。\n部署完成 Status变成Running就部署完成了，打码处为这台VPS的公网IP地址，下文以100.200.300.400来表示。\n检查IP是否被墙 在站长工具-Ping检测输入你的IP地址，点击Ping检测，如果大部分是绿的，说明IP没被墙，可以放心使用。\n如果全是红色，说明此IP地址已被墙，无法使用，根据你的VPS厂商政策，想办法更换IP，直至可用。\n配置VPS SSH登陆VPS 要配置VPS，首先通过SSH登陆VPS。打开你的终端工具，输入以下命令登陆VPS。\n1 ssh root@100.200.300.400 SSH登陆Linux服务器是基本操作，不细说了。\n启用ufw防火墙 登陆后第一件事，就是启用ufw防火墙。首先确认ufw是否已经安装，执行下述命令，若返回ufw版本号，，则说明已经安装。\n1 ufw --version 没有安装的自己安装一下。\n执行下述命令设置ufw。\n1 2 3 4 5 6 7 8 9 10 11 #设置ufw默认值 sudo ufw default deny incoming sudo ufw default allow outgoing #允许SSH连接 sudo ufw allow ssh #允许http连接 sudo ufw allow http #允许https连接 sudo ufw allow https #开机启动 sudo ufw enable ufw其他常用命令：\n1 2 3 4 5 6 7 #查看ufw状态 sudo ufw status #ufw状态带行号输出，删除某一行 sudo ufw status numbered sudo ufw delete 5 #重载ufw配置 sudo ufw reload 更改SSH默认端口 打开nano或vim等编辑器打开文件/etc/ssh/sshd_config 1 vim /etc/ssh/sshd_config 在打开文件中找到Port这一项，去掉注释符#，并将22修改为新的端口号（1025-65535），本文以9753为例。 重启ssh服务，使变更生效。 1 service sshd restart 防火墙开放新端口号 1 ufw allow 9753/tcp comment \u0026#34;SSH\u0026#34; 防火墙中删除原来的22端口，下图删除了22/tcp，同样的方法把22/tcp(v6)也删除掉。 测试新端口号登陆\n注意：为了保证你不会失联，请不要关闭当前的ssh登录窗口！而是另外开一个窗口来测试！\n在新的终端窗口，用新的端口号登陆VPS。\n1 ssh root@100.200.300.400 -p 9753 设置仅密钥登陆 把公钥上传到VPS。 1 2 3 4 5 6 7 8 # 在家目录下新建.ssh文件夹 mkdir ~/.ssh # 修改.ssh文件夹权限 chmod 700 ~/.ssh # 上传公钥。将引号内的内容替换为公钥值 echo \u0026#34;Your public key content\u0026#34; \u0026gt;\u0026gt; ~/.ssh/authorized_keys # 修改authorized_keys文件权限 chmod 600 ~/.ssh/authorized_keys 禁止密码登录 1 vim /etc/ssh/sshd_config 找到PasswordAuthentication这一项，解注释并改为no，然后保存并退出。\n有些系统只改这一个没用，还要改下面这个。如果系统没有这个文件就忽略这一步。\n1 vim /etc/ssh/sshd_config.d/50-cloud-init.conf 同样，将PasswordAuthentication这一项，解注释并改为no，然后保存并退出。\n重启ssh服务，使变更生效。 1 service sshd restart 测试密钥登陆。 打开一个新的终端，用以下命令登陆VPS。\n1 ssh -i path/to/yourprivatekeyname -p 9753 root@100.200.300.400 将path/to/yourprivatekeyname修改为VPS使用的公钥的对应的私钥路径。通常在~/.ssh/下。\n新建普通用户 执行以下命令，新建一个用户。根据提示完成即可。 1 adduser leo 给新用户起个名字，本文以leo为例。\n将新用户leo加入sudo。 1 visudo 把公钥给新用户。 1 2 3 4 5 6 7 8 9 10 # 切换至新用户leo su leo # 在新用户leo家目录下创建.ssh文件夹 mkdir ~/.ssh # 修改.ssh文件夹权限 chmod 700 ~/.ssh # 上传公钥。将引号内的内容替换为公钥值 echo \u0026#34;公钥内容\u0026#34; \u0026gt;\u0026gt; ~/.ssh/authorized_keys # 修改authorized_keys文件权限 chmod 600 ~/.ssh/authorized_keys 这样新用户就可以用密钥登陆了。\n禁止root登录 打开/etc/ssh/sshd_config，找到PermitRootLogin这一项，解注释并将yes改为no。\n1 vim /etc/ssh/sshd_config 重启sshd服务，使变更生效。\n1 sudo service sshd restart 这样，root用户就无法登陆了，以后用leo用户管理VPS。\n安装Fail2Ban 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 安装Fail2Ban sudo apt update \u0026amp;\u0026amp; sudo apt install fail2ban # 建配置文件 sudo nano /etc/fail2ban/jail.local # 将以下内容粘贴在打开文件中 ******粘贴内容开始****** [sshd] enabled = true port = 9753 filter = sshd logpath = /var/log/auth.log maxretry = 5 bantime = 7200 findtime = 600 ******粘贴内容结束****** # 启动Fail2Ban sudo systemctl start fail2ban 上述配置的意思是：600秒内5次尝试登陆ssh的IP地址会被判7200秒有期徒刑。\nFail2Ban常用命令:\n1 2 3 4 5 6 7 8 9 10 11 12 # 重启Fail2Ban sudo systemctl restart fail2ban # 查看fail2ban服务状态 sudo systemctl status fail2ban # 将Fail2Ban设为开机启动 sudo systemctl enable fail2ban # 查看状态 sudo fail2ban-client status # 查看sshd jail的详细状态 sudo fail2ban-client status sshd # 解禁指定IP sudo fail2ban-client set sshd unbanip 192.0.0.1 至此，VPS安全配置已经完成。接下开是真正的搭梯子环节。\nXRay安装与配置 不推荐用任何一键脚本，谁知道里边有没有藏什么东西。官方文档足够详细，安装配置足够简单。此部分详细内容可查阅官方文档。\nInstall Xray GitHub仓库Xray-install是Xray官方提供的安装方式，在仓库README页可以找到官方安装脚本：\n1 bash -c \u0026#34;$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)\u0026#34; @ install 后期更新新版本也是这个命令。\n一键安装，足够简单吧。\nConfig Xray 生成一个合法的 UUID 并保存备用（UUID可以简单粗暴的理解为像指纹一样几乎不会重复的 ID）。\n1 xray uuid 这个uuid要留存，后边配置会用到。\n修改Xray配置文件。\n1 sudo nano /usr/local/etc/xray/config.json 将以下内容粘贴进去。只需修改port和id两项。本文port以12345为例，id以上一步生成的为例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 # 原始版本，VMess+Kcp，访问不了ChatGPT客户端 { \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34;, \u0026#34;access\u0026#34;: \u0026#34;/var/log/xray/access.log\u0026#34;, // 这是 Linux 的路径 \u0026#34;error\u0026#34;: \u0026#34;/var/log/xray/error.log\u0026#34; }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 12345, // 服务器监听端口 \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, // 主传入协议 \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;0061c282-49f7-41d7-b223-0a9b6d8675dd\u0026#34;, // uuid，客户端与服务器必须相同 \u0026#34;alterId\u0026#34;: 0 } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;kcp\u0026#34;, //此处的 kcp 也可写成 mkcp，两种写法是起同样的效果 \u0026#34;kcpSettings\u0026#34;: { \u0026#34;uplinkCapacity\u0026#34;: 15, \u0026#34;downlinkCapacity\u0026#34;: 100, \u0026#34;congestion\u0026#34;: true, \u0026#34;readBufferSize\u0026#34;: 1, \u0026#34;writeBufferSize\u0026#34;: 1, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;wireguard\u0026#34; } } } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, // 主传出协议 \u0026#34;settings\u0026#34;: {} } ] } 开放在配置文件中指定的端口号。\n1 2 sudo ufw allow 12345/tcp comment \u0026#34;XRay\u0026#34; sudo ufw allow 12345/udp comment \u0026#34;XRay\u0026#34; 启动Xray\n1 2 3 4 5 6 # 启动XRay sudo systemctl start xray # 将XRay设为开机启动 sudo systemctl enable xray # 查看XRay运行状态 sudo systemctl status xray 看到下图这样绿色的active(running)就说明XRay已成功启动，这样服务端就配置好了。\n开启BBR加速。\n给 Debian 10 添加官方 backports 源，获取更新的软件库。\n1 sudo nano /etc/apt/sources.list 然后把下面这一条加在最后，并保存退出。\n1 deb http://archive.debian.org/debian buster-backports main 刷新软件库并查询 Debian 官方的最新版内核并安装。请务必安装你的 VPS 对应的版本（本文以比较常见的【amd64】为例）。\n1 sudo apt update \u0026amp;\u0026amp; sudo apt -t buster-backports install linux-image-amd64 修改 kernel 参数配置文件 sysctl.conf 并指定开启 BBR\n1 sudo nano /etc/sysctl.conf 把下面的内容添加进去\n1 2 net.core.default_qdisc=fq net.ipv4.tcp_congestion_control=bbr 重启 VPS、使内核更新和BBR设置都生效。\n1 sudo reboot 确认BBR开启。\n1 lsmod | grep bbr 此时应该返回tcp_bbr这样的结果。\n如果你想确认 fq 算法是否正确开启，可以使用下面的命令：\n1 lsmod | grep fq 此时应该返回sch_fq这样的结果。\n配置客户端。\n服务端配置结束，接下来就是在你的客户端进行配置。根据客户端用的代理工具不同，配置方法也不太一样。但全都是根据服务端的配置进行。主要是把IP:Port和uuid配置为与服务端一致。\n客户端配置就不细讲了。\n这样，就已经可以科学上网了。只是无法使用ChatGPT客户端，因为ChatGPT对这些VPS厂商的IP进行了封锁。\nWarp解锁ChatGPT ChatGPT封锁了VPS厂商的IP地址，而Cloudflare的Warp可以提供供我们使用的IP地址，所以我们用Warp提供的IP地址去访问ChatGPT。但是，Warp提供的IPv4地址已经被滥用，也无法访问ChatGPT客户端了，所以我们用Warp IPv6。目标是访问寻常网站时用VPS的公网IPv4地址，访问ChatGPT时用Warp的IPv6地址。\n执行下面这个脚本安装WGCF。\n1 wget -N https://gitlab.com/fscarmen/warp/-/raw/main/menu.sh \u0026amp;\u0026amp; bash menu.sh 根据需要选择语言，本文选中文了。\n因为我们这台VPS是IPv4 only的机器，没有IPv6地址，我们仅需要Warp提供IPv6地址，所以选择2. 为IPv4 only添加Warp IPv6网络接口。\n工作模式选1.全局（默认）即可。\n选择账户类型。这里根据自己的需要选择，我自己有WARP的团队版，即Zero Trust，所以选择3. Teams。\n接下来就是登陆选择的账户。Teams账户选择2.通过组织名和邮箱验证码来登陆是比较方便的。\n优先级别选择3.使用VPS初始设置（默认）即可。\n这样WGCF会开始安装，等待安装完成，运行下面的命令，可以看到有一个叫warp的网卡。\n1 sudo ifconfig 这样VPS就有IPv6地址了。\n修改XRay的配置文件\n1 sudo nano /usr/local/etc/xray/config.json 用下面的内容覆盖。将IPv4地址替换为你的VPS公网IPv4地址，将IPv6地址替换为warp网卡的地址。uuid和port也要替换为自己的。其他的不用更改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 # Warp接管IPv6流量版本，VMess+Kcp，解锁ChatGPT客户端 { \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34;, \u0026#34;access\u0026#34;: \u0026#34;/var/log/xray/access.log\u0026#34;, // 这是 Linux 的路径 \u0026#34;error\u0026#34;: \u0026#34;/var/log/xray/error.log\u0026#34; }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 12345, // 服务器监听端口 \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, // 主传入协议 \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;0061c282-49f7-41d7-b223-0a9b6d8675dd\u0026#34;, // uuID，客户端与服务器必须相同 \u0026#34;alterId\u0026#34;: 0 } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;kcp\u0026#34;, //此处的 kcp 也可写成 mkcp，两种写法是起同样的效果 \u0026#34;kcpSettings\u0026#34;: { \u0026#34;uplinkCapacity\u0026#34;: 15, \u0026#34;downlinkCapacity\u0026#34;: 100, \u0026#34;congestion\u0026#34;: true, \u0026#34;readBufferSize\u0026#34;: 1, \u0026#34;writeBufferSize\u0026#34;: 1, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;wireguard\u0026#34; } } } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, // 主传出协议 \u0026#34;settings\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;UseIPv4\u0026#34; }, \u0026#34;sendThrough\u0026#34;: \u0026#34;100.200.300.400\u0026#34; //VPS公网IPv4地址 }, { \u0026#34;tag\u0026#34;: \u0026#34;warp\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;UseIPv6\u0026#34; }, \u0026#34;sendThrough\u0026#34;: \u0026#34;2606:4700:110:88b8:5141:4387:4a3:20d1\u0026#34; //warp网卡IPv6地址 } ], \u0026#34;routing\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:openai\u0026#34;, \u0026#34;geosite:bing\u0026#34;, \u0026#34;geosite:netflix\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;warp\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; } ] } } 重启XRay，并确认Xray已成功运行。\n1 2 sudo systemctl start xray sudo systemctl status xray 在客户端连接该节点，可以发现ChatGPT客户端已经可以正常使用。\nReferences Project X官方文档 保护好你的小鸡！保姆级服务器安全教程！ vps 解锁 chatgpt 注册Cloudflare并加入ZeroTrust教程 ","date":"2024-09-18T16:26:03+08:00","permalink":"https://MasonCodingHere.github.io/p/build-your-own-ladder/","title":"私人代理——搭建专属于你的梯子"},{"content":"引言 在C++中，有三种成员函数,按照加入C++的先后顺序排列如下：\nnonstatic member functions virtual member functions static member functions 经过编译器的处理之后，这三种成员函数的调用方式是不相同的，下边我们一个一个看。 我们提供这样一个类Point3d，作例子：\n1 2 3 4 5 6 7 8 9 10 11 12 class Point3d { public: float magnitude() const; private: float _x; float _y; float _z; } float Point3d::magnitude() const{ return sqrt(_x * _x + _y * _y + _z * _z); } Nonstatic Member Functions C++有这样一个设计准则：非静态成员函数至少要和一般的非成员函数有相同的效率。也就是说，如下两个函数：\n1 2 float magnitude3d(const Point3d* _this){...} //非成员函数 float Point3d::magnitude3d() const {...} //成员函数 选择第二个函数不应该给程序带来性能上的损失，否则我还不如直接选第一个函数（不让它做类的成员函数）。\n那编译器是怎么保证这个原则的呢？答案是编译器内部会把成员函数转换为对等的非成员函数。 举个例子，下面是magnitude()的非成员函数版定义：\n1 2 3 4 5 float magnitude(const Point3d* _this){ return sqrt(_this-\u0026gt;_x * _this-\u0026gt;_x + _this-\u0026gt;_y * _this-\u0026gt;_y + _this-\u0026gt;_z * _this-\u0026gt;_z); } 乍一看，成员函数版应该效率更高，因为它直接取用_x,_y,_z这三个成员，而非成员函数版要通过指针间接取用。其实不然，因为成员函数版会被编译器内化为非成员函数版，转化步骤如下;\n改写函数原型，安插一个额外的参数（this指针）到成员函数。 非const的非静态成员函数改写如下： 1 Point3d::magnitude(Point3d *const this) 即添加了一个指针常量this。\nconst的非静态成员函数改写如下： 1 Point3d::magnitude(const Point3d* const this) 即添加一个指向常量的指针常量this。\n把每一个对非静态数据成员的存取操作改成通过this指针来存取： 1 2 3 4 5 6 7 { return sqrt( this-\u0026gt;_x * this-\u0026gt;_x + this-\u0026gt;_y * this-\u0026gt;_y + this-\u0026gt;_z * this-\u0026gt;_z ); } 将成员函数重新写成一个外部函数。将函数名称通过“mangling”，使它称为程序中独一无二的词汇： 1 extern magnitude__7Point3dFv(register Point3d* const this); 经此三步，这个函数的转换就完成了。之后，每个调用操作也会被转换。比如： 1 2 3 4 Point3d obj; Point3d* ptr = \u0026amp;obj; obj.magnitude(); ptr-\u0026gt;magnitude(); 以上两个调用操作，就会被分别转换为：\n1 2 magnitude__7Point3dFv(\u0026amp;obj); magnitude__7Point3dFv(ptr); Virtual Functions 如果magnitude()是一个虚函数，那么以下调用：\n1 ptr-\u0026gt;magnitude() 就会被内部转化为：\n1 (* ptr-\u0026gt;vptr[1])(ptr); 整体其实是通过函数指针调用magnitude()函数； vptr是编译器产生的指针，指向虚表； 1是虚表slot的索引值，关联到magnitude()函数； 第二个ptr表示this指针。 Static Member Functions 静态成员函数的主要特性是它没有this指针。因为它没有this指针，所以静态成员函数有以下特点：\n它不能直接操作类中的非静态成员； 它不能是const、volatile或virtual的； 它不需要经过类的对象来调用（尽管很多时候我们仍是这样调用它）。 如果magnitude()是一个静态成员函数，那么以下调用：\n1 2 obj.magnitude(); ptr-\u0026gt;magnitude(); 会被转换为一般的非成员函数调用，像这样：\n1 magnitude__7Point3dSFv(); 由于缺乏this指针，所以静态成员函数差不多等同于非成员函数。\n","date":"2021-06-28T20:24:15-07:00","permalink":"https://MasonCodingHere.github.io/p/cpp-member-function-calling/","title":"C++成员函数调用方式"},{"content":"引言 继承是C++作为面向对象语言的一大特性。继承提高了代码的复用和可扩展性。子类可以把父类的数据成员“完整”地继承下来，而对于父类的成员函数，子类继承的是它们的调用权。 根据子类继承父类的个数，继承分为单继承、多继承：\n单继承，子类继承一个父类 多继承：子类继承多个父类 另外还有一种虚继承，虚继承其实是为了解决多继承带了的问题而引入的。后边再详述。 单继承没什么好说的，所以不单独列一节。并且下边的美人鱼例子，虽是为讲多继承而设计，但它也包含了单继承的内容。\n多继承 我们以美人鱼为例，美人鱼既有美人的某些属性，又有鱼的某些属性，可以把美人和鱼看作美人鱼的父类；而美人和鱼都是动物，可以把动物看作美人和鱼的共同父类。这样我们就可以定义如下几个类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Animal{ public: int data_Animal; }; class Beauty : public Animal{ public: int data_Beauty; }; class Fish : public Animal{ public: int data_Fish; }; class BeautyFish : public Beauty, public Fish{ public: int data_BeautyFish; }; 如果把这四个类的继承关系画成图，你就会发现，四个类组成一个菱形，这就是菱形继承。\n那么这四个类的对象会占用多大的内存呢？我在64位Linux平台下，用g++编译器的-fdump-class-hierarchy选项做了测试，为忽略内存对齐影响，使用#pragma pack(1)设为1字节对齐。测试结果如下：\n1 2 3 4 sizeof(Animal) == 4 sizeof(Beauty) == 8 sizeof(Fish) == 8 sizeof(BeautyFish) == 20 -fdump-class-hierarchy生成的文件内容如下（只保留以上四个类）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Class Animal size=4 align=1 base size=4 base align=1 Animal (0x0x7f11187c4d80) 0 Class Beauty size=8 align=1 base size=8 base align=1 Beauty (0x0x7f111860e5b0) 0 Animal (0x0x7f11187c4de0) 0 Class Fish size=8 align=1 base size=8 base align=1 Fish (0x0x7f111860e618) 0 Animal (0x0x7f11187c4e40) 0 Class BeautyFish size=20 align=1 base size=20 base align=1 BeautyFish (0x0x7f111861e540) 0 Beauty (0x0x7f111860e680) 0 Animal (0x0x7f11187c4ea0) 0 Fish (0x0x7f111860e6e8) 8 Animal (0x0x7f11187c4f00) 8 这是一个简单的模型，各个类都没有虚函数，所以不难想象为什么结果是这样。用图来表示，各个类的对象的内存布局大致如下：\n可以看到，在BeautyFish的对象内，保存了两份data_Animal，一份来自父类Beauty，另一份来自父类Fish。从功能上讲，BeautyFish的对象没有必要保存两份data_Animal，这样是非常浪费内存空间的，这就是多继承带来的数据冗余问题。\n除了数据冗余，多继承还会带来二义性问题。假设有下面这样的程序：\n1 2 3 4 5 6 int main(){ BeautyFish bf; bf.data_Animal = 2021; //语句1 bf.Beauty::data_Animal = 2021; //语句2 bf.Fish::data_Animal = 2021; //语句3 } 语句1将会产生二义性调用，bf内有两份data_Animal，程序不知道该去给哪一个进行赋值操作； 语句2和语句3可以正常通过，因为通过作用域限定符指明了具体给哪个data_Animal进行赋值操作。 虚继承 为了解决多继承带来的数据冗余与二义性问题，C++引入了虚继承机制。虚继承使子类只保留一份间接基类的成员，既节省内存空间，又避免了二义性的麻烦。\n于BeautyFish类而言，Beauty和Fish是它的直接基类，Animal则是它的间接基类。\n具体做起来也非常简单，只需要在Beauty和Fish继承Animal时，加一个virtual关键字。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Animal{ public: int data_Animal; }; class Beauty : public virtual Animal{ public: int data_Beauty; }; class Fish : public virtual Animal{ public: int data_Fish; }; class BeautyFish : public Beauty, public Fish{ public: int data_BeautyFish; }; 同样的方法，我们再来测一下四个类的对象的大小，测试结果如下：\n1 2 3 4 sizeof(Animal) == 4 sizeof(Beauty) == 16 sizeof(Fish) == 16 sizeof(BeautyFish) == 32 -fdump-class-hierarchy生成的文件内容如下（只保留以上四个类）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 Class Animal size=4 align=1 base size=4 base align=1 Animal (0x0x7f758e638d80) 0 Vtable for Beauty Beauty::_ZTV6Beauty: 3u entries 0 12u 8 (int (*)(...))0 16 (int (*)(...))(\u0026amp; _ZTI6Beauty) VTT for Beauty Beauty::_ZTT6Beauty: 1u entries 0 ((\u0026amp; Beauty::_ZTV6Beauty) + 24u) Class Beauty size=16 align=1 base size=12 base align=1 Beauty (0x0x7f758e4825b0) 0 vptridx=0u vptr=((\u0026amp; Beauty::_ZTV6Beauty) + 24u) Animal (0x0x7f758e638de0) 12 virtual vbaseoffset=-24 Vtable for Fish Fish::_ZTV4Fish: 3u entries 0 12u 8 (int (*)(...))0 16 (int (*)(...))(\u0026amp; _ZTI4Fish) VTT for Fish Fish::_ZTT4Fish: 1u entries 0 ((\u0026amp; Fish::_ZTV4Fish) + 24u) Class Fish size=16 align=1 base size=12 base align=1 Fish (0x0x7f758e482618) 0 vptridx=0u vptr=((\u0026amp; Fish::_ZTV4Fish) + 24u) Animal (0x0x7f758e638e40) 12 virtual vbaseoffset=-24 Vtable for BeautyFish BeautyFish::_ZTV10BeautyFish: 6u entries 0 28u 8 (int (*)(...))0 16 (int (*)(...))(\u0026amp; _ZTI10BeautyFish) 24 16u 32 (int (*)(...))-12 40 (int (*)(...))(\u0026amp; _ZTI10BeautyFish) Construction vtable for Beauty (0x0x7f758e482680 instance) in BeautyFish BeautyFish::_ZTC10BeautyFish0_6Beauty: 3u entries 0 28u 8 (int (*)(...))0 16 (int (*)(...))(\u0026amp; _ZTI6Beauty) Construction vtable for Fish (0x0x7f758e4826e8 instance) in BeautyFish BeautyFish::_ZTC10BeautyFish12_4Fish: 3u entries 0 16u 8 (int (*)(...))0 16 (int (*)(...))(\u0026amp; _ZTI4Fish) VTT for BeautyFish BeautyFish::_ZTT10BeautyFish: 4u entries 0 ((\u0026amp; BeautyFish::_ZTV10BeautyFish) + 24u) 8 ((\u0026amp; BeautyFish::_ZTC10BeautyFish0_6Beauty) + 24u) 16 ((\u0026amp; BeautyFish::_ZTC10BeautyFish12_4Fish) + 24u) 24 ((\u0026amp; BeautyFish::_ZTV10BeautyFish) + 48u) Class BeautyFish size=32 align=1 base size=28 base align=1 BeautyFish (0x0x7f758e492540) 0 vptridx=0u vptr=((\u0026amp; BeautyFish::_ZTV10BeautyFish) + 24u) Beauty (0x0x7f758e482680) 0 primary-for BeautyFish (0x0x7f758e492540) subvttidx=8u Animal (0x0x7f758e638ea0) 28 virtual vbaseoffset=-24 Fish (0x0x7f758e4826e8) 12 subvttidx=16u vptridx=24u vptr=((\u0026amp; BeautyFish::_ZTV10BeautyFish) + 48u) Animal (0x0x7f758e638ea0) alternative-path 虽然只是加了个virtual，但我们可以看到上边的文件已经比之前的复杂很多了。经过分析上边的文件，结合gdb的打印类布局的内容以及网上相关博客，我还是分析出了四个类的内存布局。\nAnimal、Beauty和Fish的内存模型如下图：\nAnimal类对象的内存布局与之前一模一样，不再赘述。\nBeauty和Fish内存模型是一样的，我们以Beauty为例讲解。\n虚继承的话，子类的对象里首先存的是自己的东西，最后才是虚基类的东西； 非虚继承的话，子类的对象里首先存的是基类的东西，最后才是自己的东西。如果有多个基类，则按照继承的顺序，第一个基类被设为主基类。 由于是Beauty虚继承Animal，所以在Beauty对象的内存里，首先是虚指针vptr和Beauty自己的数据data_Beauty，最后才是从虚基类Animal继承来的data_Animal。\nBeauty的虚表有三个内容：\n第一个slot是vbase_offset，其值是12。这个值的意思是，Beauty中虚基类的部分（即Animal的部分）在Beauty对象内存中的偏移量是12。我们可以看到从Beauty对象的内存首地址偏移12个字节正好是data_Animal的地址。 第二个slot是offset_to_top。将对象从当前这个类型（this指针）转换为该对象的实际类型的地址偏移量； 第三个slot是type_info_for_Beauty,用于RTTI。 第二和第三个slot里的内容还没有弄明白，这里就先不多说了。\nBeautyFish就比较复杂了，其内存布局大致如下：\nBeautyFish非虚继承Beauty和Fish，所以BeautyFish对象的内存里，首先是基类的东西，即Beauty的虚指针和数据、Fish的虚指针和数据，然后是BeautyFish自己的数据，最后是虚基类Animal的数据。\nBeautyFish的虚表这里不再展开。\n总结 关于C++对象的内存布局，C++标准并没有作出严格的约束，只是做了一个框架性的约束，而具体的实现交由编译器自己来完成。所以就导致C++对象模型相关内容是编译器相关的，不同的编译器可能会有不同的结果。\n以我所知道的，GCC和VC++对于C++对象内存模型的实现差别就很大。比如对于虚基类，GCC的做法是扩展了虚表（virtual table）；而VC++则是模仿虚表，建了一个虚基类表（virtual base class table），正如虚指针vptr指向虚表一样，VC++会在C++对象里加一个虚基类指针vbptr，该指针指向虚基类表。\n这些东西有些繁杂，我也不能保证写的一定正确，很多东西都是自己分析得出，只为建立自己的C++对象模型观。如有朋友发现有误，欢迎指出。\n","date":"2021-06-22T06:19:43-07:00","permalink":"https://MasonCodingHere.github.io/p/cpp-multiple-inheritance/","title":"美人+鱼=美人鱼——谈C++多继承"},{"content":"引言 如《Effective C++》中所言，C++是一个语言联邦，它由以下四部分组成：\nC：可以理解为兼容C的那部分，即面向过程的； Object-Oriendted C++：即C++面向对象的部分，封装、继承、多态； Template C++：即泛型编程； STL：标准模版库，主要包含容器、迭代器、算法等。 面向过程：如C语言，数据和**处理数据的操作(即函数)**是分开的，也就是说语言本身并没有支持数据和函数之间的关联性。\n本文我们要谈的就是C++面向对象的部分内容。\n封装：于C++而言，封装实际上指的就是class，通过class把数据和函数封装在一起，对外只提供类的接口，而把实现细节隐藏起来，同时还可以通过访问权限制定数据和函数的安全等级，从而提高了安全性和隐私性。 继承：继承可以理解为代码复用，是为了提高代码的复用性和可扩展性。子类继承父类，在保留“家族传统”的同时，还允许子类有自己的“小个性”。对于父类中的数据成员，子类完整的继承下来，所谓“完整”是指这种继承是要占用内存的；而对于父类的成员函数，子类继承的只是函数的调用权。 多态：多态可以理解为接口复用，也就是通过不同的方式调用“相同的接口”将产生不同的操作。多态分为静态多态和动态多态，静态多态通过重载实现，动态多态通过虚函数实现。 多态中，关于“相同的接口”中的“相同”，不同形式的多态有一些程度上的区分。一个函数由返回类型、函数名、函数形参、函数体四部分组成。\n静态多态：通过重载实现，“相同”指的是函数名相同，函数形参必须不同，返回类型相同不相同都可以，既然要实现不同功能，函数体当然也是不同的； 动态多态：通过子类重写父类的虚函数实现，“相同”指的是除了函数体外其他完全相同，返回类型、函数名、函数形参都相同，只有函数体不同（为实现不同功能）。 静态多态是在编译期就确定下来的，编译器编译的时候会把这些函数加上各自的形参信息，这样实际上还是不同的函数，从而实现静态多态。重载的函数都在同一个类里面。\n动态多态是在运行期才能确定下来。\nC++对象基本模型 所谓C++对象模型，可以理解为对于各种支持的底层实现机制，这里我们简单关注C++对象在内存中的布局。 C++类的成员可以归纳为以下两大类五小类：\n成员函数 静态成员函数(static member functions) 非静态成员函数(non-static member functions) 虚成员函数(virtual member functions) 数据成员 静态数据成员(static data members) 非静态数据成员(non-static data members) 那么，我们可以定义这样一个类Base，在不考虑继承的情况下，它囊括了类的所有可能的成员。\n1 2 3 4 5 6 7 8 9 class Base{ public: static int fun_1(); //static member function int fun_2(); //non-static member function virtual int fun_3(){} //virtual member function private: static int data_1; //static data member int data_2; //non-static data member }; 对于这样一个类Base，实例化后，它的对象占多少字节呢？先给出答案：\n在32位机器上，sizeof(Base)得到的值为8； 在64位机器上，sizeof(Base)得到的值为16。 为什么是这样的值呢？这是由C++对象模型所决定的。在C++对象模型中：\n非静态数据成员（如data_2）由类的每个对象各自保存,根据对象的内存分配方式，存储在Heap或Stack； 静态数据成员（如data_1）只分配一次内存，由类的所有对象共用，存储在数据段(.data)； 静态成员函数（如fun_1）和非静态成员函数（如fun_2）均存储在代码段（.text）； 虚函数（如fun_3）也存储在代码段（.text），并以以下2个步骤支持之： 类产生一堆指向虚成员函数的指针，这些指针放在一个表中，称为虚表(virtual table)； 类的每个对象都存储一个指针vptr，它指向虚表。 vptr指针存放在对象内存的前四个字节，虚表存放在只读数据段(.rodata)。\n也就是说，类实例化后，对象内只有非静态数据成员和虚指针vptr。这就能解释为什么sizeof(Base)的结果是8（32位机器）和16（32位机器）了：\nint型的data_1占4个字节； vptr是指针，与机器相关，32位下占4字节，64位下占8字节； 内存对齐填补的空间。 以上三部分加起来，就是每个Base类所占的内存大小。\nC++对象内存布局 对于上述Base类，以32位平台为例，用以下分配方式分配内存后，其内存布局如下图所示。\n1 2 3 int main(){ Base* ptr = new Base; } 注：上图的内存布局旨在描述一种通用模型，而具体的要视平台、编译器而定。\nReferences ","date":"2021-06-21T20:27:56-07:00","permalink":"https://MasonCodingHere.github.io/p/cpp-object-model-via-memory-sight/","title":"内存角度看C++对象模型"},{"content":"引言 在《TCP的三次握手与四次挥手》中，我们已经了解了一个TCP连接的建立与终止的规则及这个过程中发送的各个类型的报文段。这些决定TCP应该做什么的规则其实是由当前TCP连接所属的状态决定的。当前的状态会在各种触发条件下发生改变。常见的触发条件如：\n传输或接收到某报文段； 计时器超时； 客户端/服务端应用程序的读写操作； 来自其他层的信息。 这些规则可以概括为TCP的状态转换图。\n本文就以TCP状态转换为出发点，再探TCP的连接管理相关内容。\nTCP状态转换图 TCP定义了11种状态，状态名字基于netstat命令所输出的名称。\nCLOSED状态作为开始状态点和终止状态点，但它并不能算一个“官方”状态。\n典型TCP过程 所谓典型TCP过程，这个词是我定的，即上图中黑线表示的过程的有序集合。这些黑线组成的典型TCP过程不考虑同时打开与关闭、重置等特殊情况。本节描述这个过程。\n可以看到除了CLOSING，其他10种状态均在典型TCP过程中。\n开始时，客户端/服务端均处于CLOSED状态； 服务端进程启动，调用listen函数后，服务端由CLOSED转换为LISTEN； 客户端进程启动，调用connect函数后，TCP三路握手建立连接过程被激起，客户端发送第一路握手请求的SYN报文段，然后由CLOSED转换为SYN_SENT； 服务端接收到客户端发来的SYN报文段，发起第二路握手请求，向客户端发送SYNACK报文段，然后由LISTEN转换为SYN_RCVD； 客户端接收到服务端发来的SYNACK报文段，发起第三路握手请求，向服务端发送ACK报文段，然后由SYN_SENT转换为ESTABLISHED，至此，客户端已完成连接； 服务端收到客户端发来的ACK报文段，也由SYN_RCVD转换为ESTABLISHED，至此双方连接建立完成； ESTABLISHED是通信双方双向传输数据的状态； 尽管双方均可发起主动关闭操作，但我们以客户端负责执行主动关闭为例。\n数据传输结束，客户端调用close函数关闭套接字描述符，激起TCP四路握手关闭连接的过程，客户端发送第一路握手的FIN报文段，然后由ESTABLISHED转换为FIN_WAIT_1； 服务端收到客户端发来的FIN报文段，发起第二路握手，向客户端发送ACK报文段，然后由ESTABLISHED转换为CLOSE_WAIT； 客户端收到服务端发来的ACK报文段，什么都不发送，由FIN_WAIT_1转换为FIN_WAIT_2； 服务端调用close函数，发起第三路握手，向客户端发送FIN报文段，由CLOSE_WAIT转换为LAST_ACK； 客户端收到服务端发来的FIN报文段，发起第四路握手，向服务端发送ACK报文段，由FIN_WAIT_2转换为TIME_WAIT； 服务端收到客户端发来的ACK报文段，什么都不发送，由LAST_ACK转换为CLOSED，至此服务端关闭； 客户端等待2MSL，计时器超时后，客户端由TIME_WAIT转换为CLOSED，至此双方连接彻底关闭。 非典型TCP过程 TCP状态转换图中还有一些非典型过程，在图中用蓝色表示。下边我们描述一下这些部分。这些非典型过程包括以下内容：\n连接建立超时 同时打开 同时关闭 重置报文段（RST） 连接建立超时 有时会存在连接不能建立的情况，比如服务器关闭的情况。\n当客户端发送SYN报文段，但迟迟得不到回应的时候，客户端就会频繁地发送SYN报文段，直到达到限定的次数，客户端放弃与服务端进行连接，由SYN_SENT转换为CLOSED。\nLinux系统默认重试次数为5次。\n指数回退：首个SYN报文段发送后3秒发送第二个SYN报文段，第二个报文段发送后6秒后发送第三个SYN报文段，第三个报文段发送后12秒后发送第四个SYN报文段，以此类推，即每一次回退数值都是前一次的两倍。\n同时打开过程 TCP支持双方同时打开的情况，要实现同时打开，有两个要求：\n通信双方均有彼此的套接字地址结构sockaddr_in；（正常情况下，只有客户端知道服务端的套接字地址，而服务端不知道客户端的。）；\n通信双方在收到来自对方的SYN报文段之前必须先发送一个SYN报文段。\n由于双方均同时扮演了客户端与服务端的角色，所以不能将任何一方称为客户端或服务端。\n如上图所示，同时打开的过程如下：\n双方在CLOSED状态时，通过调用connect函数，均在接收到对方的SYN报文段之前，自己就先发送了一个SYN报文段，双方均进入SYN_SENT状态； 在接收到对方发来的SYN报文段后，双方均向彼此发送SYNACK报文段，并进入SYN_RCVD状态； 双方在接收到彼此的SYNACK报文段后，均进入ESTABLISHED状态，连接建立完成。 可以看到，同时打开过程需要交换四个报文段，比普通的三路握手增加了一个。\n同时关闭过程 在接收到对方发来的FIN报文段之前，双方均向对方发送FIN报文段，这会触发同时关闭过程。\n如上图，同时关闭过程如下：\n双方在ESTABLISHED状态时，通过调用close函数，均在收到对方的FIN报文段之前，向对方发送了FIN报文段，双方均进入FIN_WAIT_1状态； 双方并没有如预期收到对方的ACK报文段，而是收到了FIN报文段，双方均向对方回应ACK报文段，均进入CLOSING状态； 双方收到对方发来的ACK报文段后，均进入TIME_WAIT状态，待2MSL超时后，进入CLOSED状态，至此连接彻底关闭。 FIN报文段还包含一个ACK段用于确认对方最近一次发来的数据。\n可以看到同时关闭过程与正常关闭过程交换相同数量的报文段，二者的区别在于：\n正常关闭过程中报文段序列是不交叉的，一个发，另一个收到之后再发； 同时关闭过程中报文段序列是交叉的，一个发的同时另一个也再发。 同时关闭过程用到了一个正常过程中没有的状态：CLOSING。\n重置报文段（RST） 一个将TCP头部中的RST字段置1的报文段称为重置报文段，它用于关闭那些已经没有必要继续存在的连接。\n以下是常见的产生重置报文段的场景：\n客户端发起一个连接请求，服务端却没有相应的进程在目的端口监听时，服务端就会给该客户端发送一个重置报文段；\n终止一条连接。在任何时刻均可以发送一个重置报文段替代FIN来终止一条连接，通过这种方式终止连接时，任何排队的数据都将被抛弃，重置报文段立即发送出去；\n在不告知另一方的情况下，通信的一端关闭或终止了连接，将导致这条TCP连接处于半开状态。这通常发生在通信一方的主机崩溃的情况下。这种情况下只要不尝试通过这条半开连接传输数据，正常工作的一端将不会检测到另一端已经崩溃（因为崩溃的一端连重置报文段或者FIN报文段都没办法发出去）。这时如果崩溃的一端重新连接，它对这条连接上另一端发送过来的数据一无所知，TCP规定此时崩溃一方将回复一个重置报文段以关闭这个连接。\nTCP的TIME_WAIT状态的目的是让任何一个受制于与数据相关的关闭连接的数据被丢弃。在这段时期，等待的一方通常不需要任何操作，它只需要维持当前状态直到2MSL的计时结束。然而，如果它在这段时期内接收到来自于这条连接的一个重置报文段时，它的TIME_WAIT状态就会被破坏而提前进入CLOSED状态。\n为什么连接的被动关闭方会发送重置报文段呢？在连接的主动关闭方进入TIME_WAIT状态前，它回复一个ACK以告知被动关闭方自己已经接收到FIN报文段，被动关闭方收到这个ACK后随即进入CLOSED状态，此时主动关闭方还在TIME_WAIT状态等待2MSL计时结束。在这个时期，网络中可能存在延时，被动关闭方之前发送的对某数据的ACK在这个时候才姗姗来迟，此时这个ACK对处于TIME_WAIT状态的主动关闭方来说是旧的消息，因此它会发送一个ACK作为响应，其中包含了最新的序列号与ACK值。已经处于CLOSED状态的被动关闭方收到这个ACK后就会发送一个重置报文段作为响应。这会导致另一端的TIME_WAIT状态过早结束而进入CLOSED状态。解决这个错误的最简单方法就是让处于TIME_WAIT状态的TCP连接不对重置报文段做出响应。\nTCP其他问题 TIME_WAIT状态 在TIME_WAIT状态中，TCP将会等待两倍于最大段生存期（MSL）的时间，MSL代表任何报文段在被丢弃前在网络中被允许存在的最长时间。\nTIME_WAIT状态有两个存在的理由：\n可靠地实现TCP全双工连接的终止； 第一个理由可以通过断开连接时客户端最终发送给服务端的，以响应服务端的FIN报文段的ACK报文段丢失来解释。服务端迟迟收不到ACK，服务端就重发它的FIN报文段，如果没有TIME_WAIT状态，客户端就直接处于CLOSED状态了，那客户端就没有该连接的信息了，客户端就会回复给服务端一个重置报文段，这就不是正常断开连接的过程了；所以客户端需要有一个TIME_WAIT状态，来维护这个连接，从而可以发送ACK来响应服务端重传过来的FIN报文段。\n允许老的重复分组在网络中消逝。 第二个理由解释：如果一条TCP连接关闭之后，双方再以相同的四元组建立新连接，如果旧连接中有一些分组还在网络中，由于IP地址和端口号相同，这些分组就可能到达新连接，这样就会产生混乱。为了避免这个情况，设置TIME_WAIT状态，等待2MSL时间，在这段时间内，旧连接的四元组仍被占用，无法用相同的四元组建立新连接，这样就避免了新旧连接的数据混乱；同时，2MSL的时间足够让旧连接的分组在网络中消逝，这样再用相同的四元组建立连接时，就可以保证新连接不会接受到旧连接的分组。\nlisten函数的第二个参数 1 2 3 #include \u0026lt;sys/socket.h\u0026gt; int listen(int sockfd, int backlog); //成功返回0，出错返回-1 backlog参数规定了内核应为sockfd排队的最大连接个数，为了理解backlog参数，我们必须认识到内核为每一个监听套接字维护两个队列：\n未完成连接队列：那些处于SYN_RCVD状态的套接字组成的队列。即客户端发来的SYN报文段已到达服务端，服务端正在等待完成三路握手过程； 已完成连接队列：那些处于ESTABLISHED状态的套接字组成的队列，即每个已完成三路握手过程的客户端对应该队列中的一项。 上述两队列之和不能超过backlog。\nTCP半关闭 TCP支持半关闭操作。\n伯克利套接字的API提供了半关闭操作，应用程序只需要调用shutdown函数来代替基本的close函数，就能实现上述操作。\n初始序列号的选取 由于客户端和服务端之间的TCP连接是由客户端的IP地址及端口号和服务端的IP地址及端口号构成的四元组所确定的，因此当客户端出现了故障把这个TCP连接断开了，之后再以相同的四元组建立新的TCP连接（也就是说客户端和服务端两次建立TCP连接都是使用了相同的IP地址和端口号），就会出现数据乱序的问题。\n换句话说，只要客户端发送了一个TCP报文段，且这个TCP报文段的四元组和序列号，和之前的TCP连接（四元组和序列号）相同的话，就会被服务端确认。这其实反映了TCP的脆弱性，如果TCP的这种缺点被一些恶意攻击者加以利用：选择合适的序列号、IP地址和端口号的话，就能伪造出一个TCP报文段，从而打断正常的TCP连接。那么通过谨慎选取初始化序列号的方式（通过算法来随机生成序列号）就会使序列号难以猜出，也就不容易利用这种缺点来进行一些恶意攻击行为。\nLinux系统采用基于时钟的方案来选取初始化序列号。\nTCP MTU的发现 MTU，即最大路径传输单元，指经过两台主机之间路径的所有网络报文段中最大传输单元的最小值。\n当中间路由器的最大传输单元小于任何一个通信端的最大段大小（MSS）时，TCP就会执行路径最大传输单元发现过程：\nIPv4头部中有一个3位的标志字段，目前只有低两位有意义，其中中间一位叫做DF位（Don\u0026rsquo;t Fragment），当该位置1时代表不能分片。\nTCP发送端发送数据时将IP数据报中的DF位置1，这样中间路由器如果收到分片才能处理的过大的数据报时，中间路由器不会分片，而是将该数据报丢弃； 路由器通过ICMP把链路上的MTU值通知TCP发送端； TCP发送端获得ICMP所通知的MTU值以后，将它设置为当前的MTU。TCP发送端发送根据这个MTU对数据报进行分片处理。如此反复，直到数据报被发送到目标主机为止没有再收到任何ICMP，就认为最后一次ICMP所通知的MTU即是一个合适的MTU值。 TCP选项 TCP头部中包含了多个选项，常见的选项如下：\nEOL：指出了选项列表的结尾，表示选项列表结束，说明无需对选项列表再进行处理。 NOP：允许发送者在必要的时候用多个4字节组填充某个字段。 MSS：最大段大小，即TCP协议所允许的从对方接收到的最大报文段。 一方把MSS发送给对方时，不是在商量，而是在通知对方，它表示在整个连接过程中都不愿意接收比MSS值大的报文段。\nMSS的值是TCP数据载荷部分的字节数，而不包括TCP与IP头部。\n建立一条TCP连接时，通信双方应该在SYN报文段的MSS选项中向对方说明自己允许的最大段大小。\nMSS的默认值是536字节，加上TCP头部20字节和IPv4头部20字节，一共组成576字节的IPv4数据报，这是标准中规定的任何主机都应该能处理的IPv4数据报的最小大小；\nIPv4中常见的MSS值为1460字节，加上TCP头部20字节和IPv4头部20字节，共组成1500字节的IPv4数据报，这正好是链路层中以太网的最大传输单元（MTU）。\n由于IPv6头部比IPv4头部大20字节，所以MSS值相应减20字节，为1440字节。\nSACK：选择确认选项。接收方通过这个选项来描述乱序的数据（空洞），帮助发送方重传； 窗口缩放选项：用于将TCP窗口大小字段的范围从16位增加至30位。该选项作为16位窗口大小的比例因子，最大比例数值为14，可将窗口大小的最大值由65535字节扩展至1GB； 窗口缩放选项只能出现在SYN报文段中，连接建立后比例因子与方向绑定，每个方向的比例因子可以各不相同。\n时间戳选项：发送方根据该选项通过每一个接收到的ACK来估算TCP连接的往返时间，并根据结果设置重传超时； 用户超时选项：指明了TCP发送者在确认对方未能成功接收数据之前愿意等待该数据ACK确认的时间； 认证选项：用于增强连接的安全性。 ","date":"2021-05-17T00:14:35-07:00","permalink":"https://MasonCodingHere.github.io/p/tcp-introduction-deeper/","title":"Tcp Introduction Deeper"},{"content":"引言 Echo客户端/服务端程序应该是网络编程领域的入门首选，可以视为网络编程领域的HelloWorld程序。\n为了深入学习网络编程，我写了这样一个程序，姑且叫它Simplest_Socket。这确实是最简单的socket通信程序。与一般的Echo服务器不同，Simplest_Socket会把客户端传来的英文字符串转换为大写再返回给客户端；而不像Echo服务器那样原样返回。\n这样设计的目的在于体现服务器的“服务”功能，尽管只是把小写转为大写，但这确实是一项服务。\n思路 TCP套接字通信由一个四元组确定一个端到端通信，即：\n（客户端IP地址，客户端端口号，服务端IP地址，服务端端口号）\n整体的时序图如下：\n上图中数据传输采用了read/write函数，套接字是一种文件类型，所以用这两个文件IO来读写套接字描述符也可以；但是套接字与普通文件又有些不同，在\u0026lt;sys/socket.h\u0026gt;中声明了专门用于socket的IO函数：send函数和recv函数。Simplest_Socket采用这两个函数来读写套接字。\n客户端 指定服务端套接字地址结构 客户端作为连接的主动发起方，它需要知道它要连到哪个服务器的哪个端口，所以在客户端程序中，首先要定义服务端的套接字地址结构，在IPv4因特网中，套接字地址结构由结构体sockaddr_in定义，它声明在头文件\u0026lt;arpa/inet.h\u0026gt;中。在这个结构体中：\nsin_family用于指定使用的网络层协议IPv4，取值为AF_INET； in_port_t被定义为uint16_t，sin_port指定端口号，由于是无符号16位整型，所以其取值范围为0~65535； sin_addr用于指定IPv4地址，它也是一个结构体in_addr，in_addr_t被定义为uint32_t，即无符号32位整型，正好与IPv4地址的大小对应。 1 2 3 4 5 6 7 8 9 #include \u0026lt;arpa/inet.h\u0026gt; struct in_addr{ in_addr_t s_addr; //IPv4地址 }; struct sockaddr_in{ sa_family_t sin_family; //协议族 in_port_t sin_port; //端口号 struct in_addr sin_addr; //IPv4地址 } 我们所定义的存放IP地址和端口号的变量均已主机字节序存放在我们的本地主机上，当进行网络通信时，需要将它们转化为网络字节序，这些工作由头文件\u0026lt;arpa/inet.h\u0026gt;中声明的htons函数和inet_pton函数来完成：\nhtons函数用于把将无符号16位整型数据由主机字节序转为网络字节序，端口号正好适用； inet_pton函数用于将主机字节序的点分十进制IP地址转换为网络字节序的二进制IP地址，IPv4地址和IPv6地址均可用该函数。 1 2 3 4 5 #include \u0026lt;arpa/inet.h\u0026gt; uint16_t htons(uint16_t hostint16); int inet_pton(int domain, const char *restrict str, void *restrict addr); 所以对于我们的客户端，我们可以定义如下套接字地址结构：\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;string.h\u0026gt; const char* server_ip = \u0026#34;127.0.0.1\u0026#34;; //服务端IP地址 const uint16_t SERVER_PORT = 2021; //服务端监听端口号 struct sockaddr_in server_sockaddr; memset(\u0026amp;server_sockaddr, 0, sizeof(server_sockaddr)); server_sockaddr.sin_family = AF_INET; //指定IPv4 server_sockaddr.sin_port = htons(SERVER_PORT); inet_pton(AF_INET, server_ip, \u0026amp;server_sockaddr.sin_addr); 声明在\u0026lt;string.h\u0026gt;中的memset函数可以用于初始化新申请的空间，将其置为指定值。\n创建套接字 既然要使用套接字，当然第一件事就是调用socket函数创建套接字。\n1 2 3 #include \u0026lt;sys/socket.h\u0026gt; int socket(int family, int type, int protocol); //成功返回非负套接字描述符，出错返回-1 对于我们的客户端：\nfamily：设置协议域为AF_INET，即IPv4； type：设置套接字类型为SOCK_STREAM，即字节流套接字； protocol：设置该参数为0，表示选择根据family和type组合系统提供的默认传输层协议。对于AF_INET和SOCK_STREAM组合，默认协议为TCP。 使用perror函数将错误原因输出到标准错误（stderr）：\n1 2 3 #include \u0026lt;stdio.h\u0026gt; void perror(const char *str); //输出格式为\u0026#34;str:错误原因\u0026#34;,错误原因依照全局变量errno的值来决定要输出的字符串 所以在客户端中这样创建客户端的套接字：\n1 2 3 4 5 6 7 8 #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int client_fd = socket(AF_INET, SOCK_STREAM, 0); //指定TCP协议 if(client_fd \u0026lt; 0){ perror(\u0026#34;socket\u0026#34;); exit(1); } 发起连接 创建完套接字之后，作为主动方的客户端要做的就是发起连接，这由connect函数完成：\n1 2 3 #include \u0026lt;sys/socket.h\u0026gt; int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen); //成功返回0；出错返回-1 sockfd参数即客户端socket函数返回的套接字描述符； servaddr参数指向一个指明了服务端IP地址和端口号的套接字地址结构，即我们之前创建的server_sockaddr； addrlen参数是servaddr参数指向的地址结构的大小，可由sizeof()运算得到。 所以，在客户端中这样发起连接：\n1 2 3 4 5 6 7 #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; if(connect(client_fd, (struct sockaddr*) \u0026amp;server_sockaddr, sizeof(server_sockaddr)) \u0026lt; 0){ perror(\u0026#34;connect\u0026#34;); exit(1); } 调用connect函数将激发TCP的三路握手过程，详情以后分析TCP状态机的时候再讲。\n数据传输 客户端发起连接之后，服务端接收连接，双方完成TCP的三路握手之后，通信链路就建立起来了，客户端可以传输数据了。\n在传输数据之前，我们定义了一个发送缓冲区sendbuf和一个接收缓冲区recvbuf。\n对于Simplest_Socket来说，客户端传输的数据就是用户输入的英文字符串，所以while函数的条件我们设置为fgets函数，fgets函数是一个声明在\u0026lt;stdio.h\u0026gt;的标准IO库函数：\n1 2 3 #include \u0026lt;stdio.h\u0026gt; char *fgets(char *restrict buf, int n, FILE *restrict fp); //成功返回buf；若已到达文件尾或出错返回NULL fgets函数从指定的流fp读取字符送到长度为n的缓冲区buf，一直读到下一个换行符为止，但不会超过n-1个字符。 fgets函数：缓冲区buf以null字节结尾。如果该行（包括换行符）的字符数超过n-1，则fgets只返回一个不完整的行，但是buf总是以null结尾。对fgets的下一次调用会继续读该行。\n我们从标准输入（stdin）读取用户输入的数据到sendbuf。然后就可以使用send函数把sendbuf中的数据通过客户端的套接字传输给服务端，\n1 2 3 #include \u0026lt;sys/socket.h\u0026gt; ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags); //成功返回发送的字节数；出错返回-1 send函数将buf中的nbytes个字节的数据通过套接字描述符sockfd发送给服务端，flags参数一般置0。 我们可以用strlen函数获取sendbuf中实际数据的长度：\n1 size_t strlen(const char* str); strlen函数从字符串的开头位置依次向后计数，直到遇见\\0，然后返回计时器的值。最终统计的字符串长度不包括\\0。 我们定义如果用户输入的是Q\\n，表示退出。这个用strcmp函数来完成：\n1 2 #include \u0026lt;string.h\u0026gt; int strcmp(const char *str1, const char *str2) strcmp函数返回值为0则表示参与比较的两个字符串相等。 发送完数据之后要做的就是要接收服务端返回的数据，这由recv函数来完成：\n1 2 3 #include \u0026lt;sys/socket.h\u0026gt; ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags); //返回值：返回数据的字节长度；若无可用数据或对等方已经按序结束，返回0；出错返回-1 recv函数通过套接字描述符sockfd接收数据至buf，nbytes参数指定buf的大小，flags参数一般置0。 接收完数据后，通过fputs函数把recvbuf的内容输出到标准输出（stdout）。\n1 2 #include \u0026lt;stdio.h\u0026gt; int fputs(const char *restrict str, FILE *restrict fp); fputs函数将一个以null字节终止的字符串str写到指定的流fp，尾端的终止符null不写出。 在准备发送和接收下一次的新数据之前，我们用memset函数将sendbuf和recvbuf的空间全部置0：\n1 2 #include \u0026lt;string.h\u0026gt; void *memset(void *str, int c, size_t n) memset函数将参数 str 所指向的字符串的前 n 个字符置为值c。 所以在客户端这样写数据传输部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;string.h\u0026gt; const int BUFFER_SIZE = 1024; //定义缓冲区大小 char sendbuf[BUFFER_SIZE]; char recvbuf[BUFFER_SIZE]; while(fgets(sendbuf, sizeof(sendbuf), stdin)){ //从stdin读入待传输数据至sendbuf send(client_fd, sendbuf, strlen(sendbuf), 0); //将sendbuf中的数据通过client_fd套接字传输 if(strcmp(sendbuf, \u0026#34;Q\\n\u0026#34;) == 0) //输入Q表示退出 break; recv(client_fd, recvbuf, sizeof(recvbuf), 0); //从client_fd套接字接收数据，保存至recvbuf fputs(recvbuf, stdout);//将recvbuf中的数据输出至stdout memset(sendbuf, 0, sizeof(sendbuf));//将sendbuf的内存值置0 memset(recvbuf, 0, sizeof(recvbuf));//将recvbuf的内存值置0 } 关闭连接 当用户输入Q\\n，表示要退出连接。\n因为套接字也是一种文件类型，所以我们可以像关闭普通的文件描述符一样，用close函数来关闭它。\n1 2 3 #include \u0026lt;unistd.h\u0026gt; int close(int fd); //成功返回0；出错返回-1 所以在客户端这样写关闭连接部分：\n1 2 3 #include \u0026lt;unistd.h\u0026gt; close(client_fd); 服务端 服务端部分内容与客户端一致，重复部分不再赘述。\n定义服务端套接字地址结构 这一部分与客户端相同，也是定义服务端的套接字地址结构。\n创建监听套接字 服务端作为被动接收连接的一方，需要创建一个监听套接字，这个也跟客户端创建套接字一样。\n绑定 对于服务端，我们一般还会指定一个固定的端口号，并且这个端口号还应该让想用这个服务器的客户端知道，也就是服务端的监听套接字要绑定一个固定的套接字地址结构，这样客户端在想要连接到这个服务端时，才可以知道我应该连接到哪个套接字地址结构，如果你的端口号一直变，那客户端就比较难受了。\n这个绑定工作由bind函数完成。\n1 2 3 #include \u0026lt;sys/socket.h\u0026gt; int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen); //成功返回0；出错返回-1 bind函数将套接字sockfd绑定到套接字地址结构myaddr，addrlen为myaddr的长度，可由sizeof()得到。 转化为被动套接字 由socket函数创建的套接字是一个主动套接字，即它是一个会调用connect函数发起连接的客户端套接字。\n那问题就出来了，我服务端的套接字可不是要主动发起连接的，而是要被动接受连接的。那么就需要把socket函数创建的主动套接字转化为被动套接字，这个工作由listen函数来完成：\n1 2 3 #include \u0026lt;sys/socket.h\u0026gt; int listen(int sockfd, int backlog); //成功返回0；出错返回-1 listen函数把主动套接字sockfd转化为被动套接字，指示内核应该接受指向该套接字的连接请求。 backlog参数规定了内核应该为sockfd套接字排队的最大连接个数。 调用listen函数会使TCP服务器状态由ClOSED转为LISTEN。\n接收请求 接下来就是接收客户端的连接请求，该工作由accept函数完成。\n1 2 #include \u0026lt;sys/socket.h\u0026gt; int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen); accept函数接收监听套接字描述符，并返回一个已连接套接字描述符。 cliaddr参数和addrlen用于返回客户的套接字地址结构及其大小，若不关心客户端的身份，将二者设为NULL即可。 数据传输 数据传输过程也与客户端没有太大不同。\n关闭连接 关闭连接也与客户端相同，只是服务端要关闭两个套接字：\n监听套接字 已连接套接字 源程序 客户端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;sys/socket.h\u0026gt; //socket系列函数头文件 #include \u0026lt;arpa/inet.h\u0026gt; //sockaddr_in结构体、inet_pton函数和htons函数头文件 #include \u0026lt;string.h\u0026gt; //strlen函数、strcmp函数和memset函数头文件 #include \u0026lt;unistd.h\u0026gt; //close函数头文件 #include \u0026lt;stdlib.h\u0026gt; //exit函数头文件 #include \u0026lt;stdio.h\u0026gt; //fgets函数、fputs函数、perror函数头文件 const int BUFFER_SIZE = 1024; //定义缓冲区大小 const char* server_ip = \u0026#34;127.0.0.1\u0026#34;; //服务端IP地址 const uint16_t SERVER_PORT = 2021; //服务端监听端口号 int main(){ //定义服务端套接字地址结构 struct sockaddr_in server_sockaddr; memset(\u0026amp;server_sockaddr, 0, sizeof(server_sockaddr)); server_sockaddr.sin_family = AF_INET; //指定IPv4 server_sockaddr.sin_port = htons(SERVER_PORT); inet_pton(AF_INET, server_ip, \u0026amp;server_sockaddr.sin_addr); //创建客户端套接字描述符 int client_fd = socket(AF_INET, SOCK_STREAM, 0); //指定TCP协议 if(client_fd \u0026lt; 0){ perror(\u0026#34;socket\u0026#34;); exit(1); } //发起连接 if(connect(client_fd, (struct sockaddr*) \u0026amp;server_sockaddr, sizeof(server_sockaddr)) \u0026lt; 0){ perror(\u0026#34;connect\u0026#34;); exit(1); } //开始数据传输 char sendbuf[BUFFER_SIZE]; char recvbuf[BUFFER_SIZE]; while(fgets(sendbuf, sizeof(sendbuf), stdin)){ //从stdin读入待传输数据至sendbuf send(client_fd, sendbuf, strlen(sendbuf), 0); //将sendbuf中的数据通过client_fd套接字传输 if(strcmp(sendbuf, \u0026#34;Q\\n\u0026#34;) == 0) //输入Q表示退出 break; recv(client_fd, recvbuf, sizeof(recvbuf), 0); //从client_fd套接字接收数据，保存至recvbuf fputs(recvbuf, stdout);//将recvbuf中的数据输出至stdout memset(sendbuf, 0, sizeof(sendbuf));//将sendbuf的内存值置0 memset(recvbuf, 0, sizeof(recvbuf));//将recvbuf的内存值置0 } //关闭连接 close(client_fd); return 0; } 服务端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026lt;sys/socket.h\u0026gt; //socket系列函数头文件 #include \u0026lt;arpa/inet.h\u0026gt; //sockaddr_in结构体、inet_pton函数、htons函数头文件 #include \u0026lt;string.h\u0026gt; //strlen函数、strcmp函数和memset函数头文件 #include \u0026lt;unistd.h\u0026gt; //close函数头文件 #include \u0026lt;stdlib.h\u0026gt; //exit函数头文件 #include \u0026lt;stdio.h\u0026gt; //perror函数头文件 #include \u0026lt;ctype.h\u0026gt; //toupper函数头文件 const char* server_ip = \u0026#34;127.0.0.1\u0026#34;; //指定服务端IP地址 const uint16_t SERVER_PORT = 2021;//指定监听端口号 const int QUEUE = 1024; //用于listen函数第二个参数，指定内核应为相应套接字排队的最大连接数 const int BUFFER_SIZE = 1024;//指定缓冲区大小 int main(){ //定义服务端套接字地址结构并赋值 struct sockaddr_in server_sockaddr; memset(\u0026amp;server_sockaddr, 0, sizeof(server_sockaddr)); server_sockaddr.sin_family = AF_INET; //指定IPv4 server_sockaddr.sin_port = htons(SERVER_PORT); inet_pton(AF_INET, server_ip, \u0026amp;server_sockaddr.sin_addr); //创建一个监听套接字描述符 int listen_fd = socket(AF_INET, SOCK_STREAM, 0); //指定TCP协议 if(listen_fd \u0026lt; 0){ perror(\u0026#34;socket\u0026#34;); exit(1); } //将监听套接字描述符绑定到套接字地址结构 if(bind(listen_fd, (struct sockaddr*) \u0026amp;server_sockaddr, sizeof(server_sockaddr)) \u0026lt; 0){ perror(\u0026#34;bind\u0026#34;); exit(1); } //开始监听 if(listen(listen_fd, QUEUE) \u0026lt; 0){ perror(\u0026#34;listen\u0026#34;); exit(1); } //接受连接请求，创建 已连接套接字描述符 int conn_fd = accept(listen_fd, NULL, NULL); if(conn_fd \u0026lt; 0){ perror(\u0026#34;accept\u0026#34;); exit(1); } //开始数据传输 char sendbuf[BUFFER_SIZE]; char recvbuf[BUFFER_SIZE]; while(1){ memset(recvbuf, 0, sizeof(recvbuf)); memset(sendbuf, 0, sizeof(sendbuf)); recv(conn_fd, recvbuf, sizeof(recvbuf), 0); //从conn_fd套接字接收数据，保存至recvbuf if(strcmp(recvbuf, \u0026#34;Q\\n\u0026#34;) == 0) //如果收到的数据是Q，表示退出 break; fputs(recvbuf, stdout); //将收到的数据原样输出至stdout //将recvbuf中的小写字母转为大写，新数据保存至sendbuf for(int i = 0; i \u0026lt; strlen(recvbuf); ++i){ if(islower(recvbuf[i])) sendbuf[i] = toupper(recvbuf[i]); else sendbuf[i] = recvbuf[i]; } send(conn_fd, sendbuf, strlen(sendbuf), 0); //将sendbuf中的数据通过conn_fd套接字传输 } //关闭连接及监听描述符 close(conn_fd); close(listen_fd); return 0; } 数据流通图 ","date":"2021-05-14T06:44:38-07:00","permalink":"https://MasonCodingHere.github.io/p/helloworld-on-network-programming/","title":"网络编程领域的HelloWorld程序"},{"content":"引言 所谓可靠传输，有以下四点要求：\n不损坏，即接收到的数据不存在比特差错； 不丢失，即接收到的数据无间隙； 不重复，即接收到的数据不重复； 不乱序，即接收到的数据是按次序的。 通信介质由于一些原因可能会造成比特差错和分组丢失。\n使用差错校正码，即添加一些冗余比特用于恢复比特差错； 重传机制：即重新传送信息，直到它被正确接收为止。重传可以解决比特差错和分组丢失。TCP就采用重传机制。 重传机制 通过重传机制解决比特差错和分组丢失，需要判断两个问题：\n是不是发生了分组丢失，即接收方是否已收到分组？ 是不是发生了比特差错，即接收方收到的分组是否与之前发送方发送的一样？ 对于检测是否发生了比特差错，可以通过校验和来完成；但是校验和只能检测，并不能实现差错纠正。\nACK机制 为了判断重传机制带来的第一个问题（即是否发生分组丢失），引入了ACK机制：\n接收方收到分组后，给发送方发送一个ACK，以确认自己收到了分组；发送方收到ACK后，再发送下一个分组，继续等待新分组的ACK，这个过程就这样进行下去。\n但ACK机制也带来了一些问题：\n发送方等待ACK应该等多长时间？ 这个问题比较复杂，暂时不讨论，到《TCP的超时与重传》再讨论。\n如果ACK丢失了怎么办？ 这个问题比较容易，超过了发送方等待ACK的时间，发送方就再把原分组发送一遍就可以了。当然这可能带来分组重复问题。\n如果分组接收到了，但是通过校验和检测到分组存在比特差错怎么办？ 这个也比较简单，接收方收到存在比特差错的分组后，将不发送ACK，时间一到，发送方重发完整到达的无差错的分组。\n序列号机制 从上边可以看出，对于ACK丢失的情况，发送方简单地重发原分组，这将导致接收方接收到重复的分组。\n为了解决分组重复问题，引入序列号机制来解决\n发送方发送分组时，每个分组都有一个唯一的序列号，这个序列号由分组自身一直携带着。接收方可以使用这个序列号来判断它是否已经收到过这个分组，如果是则丢弃它，保留之前的就好了。\n滑动窗口机制 到目前为止，以上的协议是可靠的，但是效率比较低，因为它是一个停等协议，即发送方注入一个分组到通信路径，然后停下来等待，直到接收到来自接收方给这个分组反馈的ACK，发送方才能发送下一个分组。\n为了提高吞吐量，我们可以允许发送方同时发送多个分组，这将带来更多需要考虑的问题：\n发送方每次应该发多少个分组？ 发送方应该保存哪些分组的副本已备重传？ 接收方的ACK机制如何区分哪些分组收到了，哪些分组还没收到？ 接收方收到分组的顺序与发送方的发送顺序不同，即乱序问题如何解决？ 为了解决这些问题，引入了滑动窗口机制。\n上图显示了一个发送方窗口，3号分组已被发送并确认，所以由发送方保存的它的副本可以被释放；7号分组在发送方已准备好，但还未被发送，因为它还没有进入窗口。\n现在我们可以想象，发送方下一步就接收到分组4的ACK，所以整个窗口向右滑动一个分组，变成下图：\n这意味着4号分组现在可以释放了，而7号分组可以被发送了。\n一般，发送方和接收方都有自己的滑动窗口结构。\n发送方的窗口记录着哪些分组可以被释放，哪些分组正在等待ACK，哪些分组还不能被发送；\n接收方的窗口记录着哪些分组已接收和确认，哪些分组是下一步期望接收的，以及哪些分组即使被接收也会因内存限制而被丢弃。\n滑动窗口机制又带来一些需要考虑的问题：\n窗口大小应该是多少？ 如果接收方或网络处理不过来发送方的数据率时该怎么办？ 流量控制和拥塞控制 为了解决滑动窗口机制带来的问题，引入了流量控制和拥塞控制。\n流量控制 流量控制：当接收方相对于发送方太慢时，强迫发送方慢一点。\n流量控制的主要形式为基于滑动窗口进行流量控制，在这种方法里：\n滑动窗口大小不固定，允许随时间而变动； 接收方通过窗口通告通知发送方更新自己的窗口大小； 窗口通告通常与ACK一起由同一个分组携带，即发送方在向右滑动窗口的同时调整窗口的大小。 拥塞控制 流量控制解决了接收方相对于发送方慢的问题，但是一般在发送方和接收方之间还有很多路由器，它们的内存有限，如果发送方发送的太快，快到超过了这之间某台路由器的承受能力，就会导致丢包。\n这个问题通过拥塞控制机制来解决。\n超时重传机制 为解决“发送方等待ACK应该等多长时间才能判定分组丢失并重发它”这个问题，引入了超时重传机制。\n直观上，发送方重新发送一个分组之前应等待以下时间的总和：\n发送分组所用的时间； 接收方处理分组的时间； 接收方发送一个ACK所用的时间； ACK到达发送方所用的时间； 发送方处理ACK所用的时间。 不幸的是，谁都不知道这些时间是多少，而且它们会随网络环境和主机负载而变化。\n所以采用的策略是：让协议实现尝试去估计这些时间，称为往返时间估计（RTT）。\nTCP中的可靠性 TCP服务模型\nTCP提供了一种面向连接的可靠的字节流服务。\n面向连接的，即通信双方需要建立一条端到端连接；\n字节流：应用层传下来的数据会被TCP打散成TCP认为的最佳大小的块来发送，一般使得每个报文段按照不会被分片的单个IP层数据报的大小来划分。\nTCP通过前述各种技术机制的变种，实现了可靠数据传输。\n序列号：在TCP中序列号实际代表了每个分组的第一个字节在整个字节流中的字节偏移，而非分组号；\n校验和：在TCP中用于检测传送中的比特差错；\n重传计时器：当TCP发送一组报文段时，它通常设置一个重传计时器，等待对方的ACK。TCP不会为每个报文段各自设置一个重传计时器，而是发送一个窗口的数据只设置一个重传计时器，当ACK到达时更新超时；\nACK机制：TCP的ACK是累积的，即指示字节号N的ACK到达意味着N（不含N）之前的所有字节都成功收到了。\n窗口通告：因为TCP提供的是双工服务，A给B发数据时的TCP报文段同时也包含了对B发给A的数据的ACK，同时每个报文段也包含一个窗口通告实现相反方向上的流量控制。\n乱序问题：TCP绝不会以杂乱次序给上层应用程序发数据。因此，TCP接收端可能会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号报文段一一到达，空洞被填满再往应用程序交付数据。\nTCP头部结构 源/目的端口：与IP头部中的源/目的IP地址一起，唯一地标识了每个连接； 序列号：标识了TCP发送端到接收端的数据流的一个字节，该字节代表着包含该序列号的报文段的数据中的第一个字节； 确认号：其值是该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节的序列号加1； 头部长度：指出TCP头部的长度，以4字节为单位。作为一个4位字段，TCP头部被限制为最大60字节； 保留：4位，暂时没用，填充为0； CWR：1位，拥塞窗口减（发送方降低发送速率）； ECE：1位，ECN回显（发送方接收到了一个更早的拥塞通告）； URG：1位，紧急（使紧急指针字段有效）； ACK：1位，确认（使确认号字段有效）； PSH：1位，推送（接收方应尽快给应用程序传送这个数据）； RST：1位，重置连接； SYN：1位，用于初始化一个连接的同步序列号； FIN：1位，该报文段的发送方已经结束向对方发送数据； 窗口大小：窗口通告，以字节为单位通知对方更新窗口大小； TCP校验和：检测比特差错； 紧急指针：用于发送紧急数据，参考《APUE》带外数据； 选项：最常见的选项是MSS（最大端大小）； ","date":"2021-05-10T00:07:46-07:00","permalink":"https://MasonCodingHere.github.io/p/tcp-introduction/","title":"TCP:传输控制协议"}]