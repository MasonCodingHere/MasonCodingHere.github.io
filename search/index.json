[{"content":"new expression 分配内存-调用构造函数-返回指针\nThe new operator is an operator which denotes a request for memory allocation on the Heap. If sufficient memory is available, new operator initializes the memory and returns the address of the newly allocated and initialized memory to the pointer variable. When you create an object of class using new keyword(normal new).\nThe memory for the object is allocated using operator new from heap. The constructor of the class is invoked to properly initialize this memory. operator new 只分配内存-返回指针/抛出异常\nOperator new is a function that allocates raw memory and conceptually a bit similar to malloc().\nIt is the mechanism of overriding the default heap allocation logic. It doesn’t initializes the memory i.e constructor is not called. However, after our overloaded new returns, the compiler then automatically calls the constructor also as applicable. It’s also possible to overload operator new either globally, or for a specific class New operator vs operator new Operator vs function: new is an operator as well as a keyword whereas operator new is only a function. New calls “Operator new”: “new operator” calls “operator new()” , like the way + operator calls operator +() “Operator new” can be Overloaded: Operator new can be overloaded just like functions allowing us to do customized tasks. Memory allocation: ‘new expression’ call ‘operator new’ to allocate raw memory, then call constructor. References ","date":"2024-09-30T09:52:09+08:00","permalink":"https://MasonCodingHere.github.io/p/things-about-new/","title":"C++ new那些事儿"},{"content":"前言 本文待完善。\n整体思路 使用Hugo作为博客框架，在本地编写Markdown文件，构成博客站点源码库。将源码库上传至GitHub仓库MasonHugoBlog，并设置GitHub Action，由GitHub Action运行hugo命令生成博客HTML文件并上传至MasonCodingHere.github.io，最终由GitHub Pages完成部署。\n所以需要两个GitHub仓库。\nMasonHugoBlog：用于存储站点源码。 MasonCodingHere.github.io：用于存储生成的HTML文件。 Hugo安装与配置 参考Hugo官方文档，根据操作系统选择安装方式。本文以macOS为例。\n前提 Hugo依赖Git和Go，所以要先安装这两个。\n不展开讲了。\n安装hugo 本文采用Homebrew的安装方式\n1 brew install hugo 安装结束，执行以下命令，看到版本号说明安装成功。\n1 hugo version 新建站点 在你希望的位置执行下面的命令，新建一个Hugo站点。\n1 hugo new site MasonHugoBlog 这样会出现一个名为MasonHugoBlog的文件夹，这就是博客源码。\n选择主题 在官方主题库选择一个主题，当然也可以去GitHub找官方主题库里没有的主题。本文选择Stack主题。\n本文选择Git Submodule的方式安装。\n1 2 3 cd MasonHugoblog git init git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack 这样theme文件夹下就会出现该主题。我想让我的博客跟Stack主题提供的Demo站点一样，所以做了一下事情。\n把MasonHugoblog/themes/Hugo-theme-stack/exampleSite/content/下的内容复制到MasonHugoblog/content/。 删除MasonHugoblog/hugo.toml，把MasonHugoblog/themes/Hugo-theme-stack/Hugo.yaml复制到MasonHugoblog/。 这样执行以下命令，在本地预览，发现已经跟Demo一致。\n1 hugo server -D 配置博客 各种个性化配置，包括该博客名称、换头像、改链接、去除自己不需要的多语言支持等等，在hugo.yaml中配置。\n删除默认博文、删除默认分类和标签、修改博文默认模版等等。\n不展开说了。\nGitHub Actions Push to GitHub 接下来就是把整个文件夹推到GitHub，在GitHub新建一个仓库MasonHugoBlog。把本地的MasonHugoBlog文件夹推到这个仓库。不细说了。\n之后，因为我们以后写文章、更新博客，都是要推这个文件夹，所以写一个脚本更方便，在MasonHugoBlog下新建一个名为deploy.sh的脚本文件，把以下内容复制粘贴过去。这样以后写完md文件，直接执行./deploy.sh就完成部署了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #!/bin/bash # Check if the directory /public exists if [ -d \u0026#34;./public\u0026#34; ]; then # If it exists, delete the directory rm -rf ./public echo \u0026#34;./public directory has been deleted.\u0026#34; else # If it doesn\u0026#39;t exist, print a message echo \u0026#34;./public directory does not exist.\u0026#34; fi # Check if a commit message was provided as an argument if [ -z \u0026#34;$1\u0026#34; ]; then # If no commit message is provided, use the current date and time COMMIT_MSG=\u0026#34;Update at $(date)\u0026#34; else # Use the provided commit message COMMIT_MSG=\u0026#34;$1\u0026#34; fi # Add all changes git add . # Commit changes with the provided message git commit -m \u0026#34;$COMMIT_MSG\u0026#34; # Push changes to the \u0026#39;main\u0026#39; branch git push origin main # Print a success message echo \u0026#34;Changes have been pushed to GitHub successfully!\u0026#34; 因为我们想这个库只保存源码，所以生成的静态HTML文件我们不要，所以在上传之前先检测有无/public文件夹，有的话删掉再上传。\nDeploy Key 在本地用sshkeygen生成一对key\n公钥给MasonCodingHere.github.io的Deploy key\n私钥给MasonHugoBlog的Actions的secrets。\nMasonHugoBlog的Workflow permissions改为Read and write permissions\nGitHub Actions 给MasonHugoBlog添加Actions\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 name: Deploy Hugo to GitHub Pages on: push: branches: - main # Trigger deployment when changes are pushed to the main branch jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout the repository uses: actions/checkout@v2 with: submodules: true - name: Set up Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.134.2\u0026#39; extended: true - name: Build the website run: hugo - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.DEPLOY_KEY }} publish_dir: ./public # This is the directory where Hugo generates static files external_repository: MasonCodingHere/MasonCodingHere.github.io publish_branch: main GitHub图床 每个repo有1G的大小限制，如果把图片也传到博客仓库，很快就会满。\n在GitHub新建一个图床库PicsBed_1\n生成一个Token，选public_repo\n安装PicGo，设置Token。\n为PicsBed_1添加Actions如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 name: Update README with Directory Structure on: push: branches: - main jobs: update-readme: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v2 - name: Generate directory structure run: | echo \u0026#34;# Directory Structure\u0026#34; \u0026gt; structure.txt echo \u0026#34;\\`\\`\\`\u0026#34; \u0026gt;\u0026gt; structure.txt tree -I \u0026#34;.git|node_modules|structure.txt\u0026#34; \u0026gt;\u0026gt; structure.txt echo \u0026#34;\\`\\`\\`\u0026#34; \u0026gt;\u0026gt; structure.txt - name: Update README run: | cat structure.txt \u0026gt; README.md - name: Commit changes run: | git config --local user.name \u0026#34;GitHub Action\u0026#34; git config --local user.email \u0026#34;action@github.com\u0026#34; git add README.md git commit -m \u0026#34;Update directory structure in README\u0026#34; git push env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} References Hugo官方文档 Stack主题官方网站 Stack主题官方GitHub仓库 图片上传工具PicGo官网 图片上传工具PicGo官方GitHub仓库 ","date":"2024-09-20T15:18:02+08:00","permalink":"https://MasonCodingHere.github.io/p/build-your-blog/","title":"Hugo + GitHub Pages搭建个人博客"},{"content":"前言 大家都知道，像Google、Twitter这类的海外网站在中国大陆是无法直接访问的。大家还知道，连上VPN就可以访问这些网站了。至于其中的细节，大多数人就不知道了，确实也没必要知道。但是有一点我们要明白，VPN能够起到效果的重要原因是GFW没有封锁一切海外网站。正是由于这个原因，我们才能有空子可钻。\n技术上讲，VPN≠翻墙。不过在大陆VPN已经成为翻墙的代名词，这里就不咬文嚼字了。\n在互联网中，IP地址是我们的“身份证”。这些被禁的海外网站也有自己的IP地址，可惜被墙了，所以我们无法直接访问。还存在一些IP地址，没有被墙，我们可以访问。一系列的翻墙技术正是建立在这个基础上。\n假设有这样一个IP地址A，A没有被GFW墙掉，并且A作为互联网的一员，可以访问那些被墙的网站。我们可以把要访问Google的请求发给A，由A帮我们访问，再把结果发给我们，这就是代理的原理，也是一系列翻墙技术得以实现的基础。\n购买VPS 我们需要一个没有被墙的IP地址，购买一台海外VPS可以满足这个需求。VPS其实就是一台位于海外的云服务器。\n有很多VPS厂商，比如BandWagon、Vultr、CloudCone等等，本文以Vultr为例，其他的厂商也大同小异。\n注册并登陆Vultr，点击右上角的Deploy按钮按以下步骤部署一台VPS。\n选择VPS类型和位置 类型选Shared CPU即可。\n位置看自己需求，这里以美国Los Angeles为例。\n选择系统镜像 选一个操作系统，服务器嘛，自然是要选Linux，推荐选择Debian，比较稳定。\n选择Plan 根据需求，选择一个配置，配置越高越贵。这里选择最便宜的5$/month的Plan。\n其他设置 去掉Auto Backups，费钱。\n去掉IPv6，不需要。\n这里可以把SSH key上传一下，把本地电脑~/.ssh/的公钥传到Vultr，这样等部署完可以直接密钥登陆，不用输密码，方便很多。\n在Server Hostname设置一下主机名，自己起个名即可，本文以Test为例。\n下单 这样就配好了，确认一下数量和价格，点击Deploy Now就开始部署了。\n部署过程或许需要几分钟，耐心等待一下。\n部署完成 Status变成Running就部署完成了，打码处为这台VPS的公网IP地址，下文以100.200.300.400来表示。\n检查IP是否被墙 在站长工具-Ping检测输入你的IP地址，点击Ping检测，如果大部分是绿的，说明IP没被墙，可以放心使用。\n如果全是红色，说明此IP地址已被墙，无法使用，根据你的VPS厂商政策，想办法更换IP，直至可用。\n配置VPS SSH登陆VPS 要配置VPS，首先通过SSH登陆VPS。打开你的终端工具，输入以下命令登陆VPS。\n1 ssh root@100.200.300.400 SSH登陆Linux服务器是基本操作，不细说了。\n启用ufw防火墙 登陆后第一件事，就是启用ufw防火墙。首先确认ufw是否已经安装，执行下述命令，若返回ufw版本号，，则说明已经安装。\n1 ufw --version 没有安装的自己安装一下。\n执行下述命令设置ufw。\n1 2 3 4 5 6 7 8 9 10 11 #设置ufw默认值 sudo ufw default deny incoming sudo ufw default allow outgoing #允许SSH连接 sudo ufw allow ssh #允许http连接 sudo ufw allow http #允许https连接 sudo ufw allow https #开机启动 sudo ufw enable ufw其他常用命令：\n1 2 3 4 5 6 7 #查看ufw状态 sudo ufw status #ufw状态带行号输出，删除某一行 sudo ufw status numbered sudo ufw delete 5 #重载ufw配置 sudo ufw reload 更改SSH默认端口 打开nano或vim等编辑器打开文件/etc/ssh/sshd_config 1 vim /etc/ssh/sshd_config 在打开文件中找到Port这一项，去掉注释符#，并将22修改为新的端口号（1025-65535），本文以9753为例。 重启ssh服务，使变更生效。 1 service sshd restart 防火墙开放新端口号 1 ufw allow 9753/tcp comment \u0026#34;SSH\u0026#34; 防火墙中删除原来的22端口，下图删除了22/tcp，同样的方法把22/tcp(v6)也删除掉。 测试新端口号登陆\n注意：为了保证你不会失联，请不要关闭当前的ssh登录窗口！而是另外开一个窗口来测试！\n在新的终端窗口，用新的端口号登陆VPS。\n1 ssh root@100.200.300.400 -p 9753 设置仅密钥登陆 把公钥上传到VPS。 1 2 3 4 5 6 7 8 # 在家目录下新建.ssh文件夹 mkdir ~/.ssh # 修改.ssh文件夹权限 chmod 700 ~/.ssh # 上传公钥。将引号内的内容替换为公钥值 echo \u0026#34;Your public key content\u0026#34; \u0026gt;\u0026gt; ~/.ssh/authorized_keys # 修改authorized_keys文件权限 chmod 600 ~/.ssh/authorized_keys 禁止密码登录 1 vim /etc/ssh/sshd_config 找到PasswordAuthentication这一项，解注释并改为no，然后保存并退出。\n有些系统只改这一个没用，还要改下面这个。如果系统没有这个文件就忽略这一步。\n1 vim /etc/ssh/sshd_config.d/50-cloud-init.conf 同样，将PasswordAuthentication这一项，解注释并改为no，然后保存并退出。\n重启ssh服务，使变更生效。 1 service sshd restart 测试密钥登陆。 打开一个新的终端，用以下命令登陆VPS。\n1 ssh -i path/to/yourprivatekeyname -p 9753 root@100.200.300.400 将path/to/yourprivatekeyname修改为VPS使用的公钥的对应的私钥路径。通常在~/.ssh/下。\n新建普通用户 执行以下命令，新建一个用户。根据提示完成即可。 1 adduser leo 给新用户起个名字，本文以leo为例。\n将新用户leo加入sudo。 1 visudo 把公钥给新用户。 1 2 3 4 5 6 7 8 9 10 # 切换至新用户leo su leo # 在新用户leo家目录下创建.ssh文件夹 mkdir ~/.ssh # 修改.ssh文件夹权限 chmod 700 ~/.ssh # 上传公钥。将引号内的内容替换为公钥值 echo \u0026#34;公钥内容\u0026#34; \u0026gt;\u0026gt; ~/.ssh/authorized_keys # 修改authorized_keys文件权限 chmod 600 ~/.ssh/authorized_keys 这样新用户就可以用密钥登陆了。\n禁止root登录 打开/etc/ssh/sshd_config，找到PermitRootLogin这一项，解注释并将yes改为no。\n1 vim /etc/ssh/sshd_config 重启sshd服务，使变更生效。\n1 sudo service sshd restart 这样，root用户就无法登陆了，以后用leo用户管理VPS。\n安装Fail2Ban 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 安装Fail2Ban sudo apt update \u0026amp;\u0026amp; sudo apt install fail2ban # 建配置文件 sudo nano /etc/fail2ban/jail.local # 将以下内容粘贴在打开文件中 ******粘贴内容开始****** [sshd] enabled = true port = 9753 filter = sshd logpath = /var/log/auth.log maxretry = 5 bantime = 7200 findtime = 600 ******粘贴内容结束****** # 启动Fail2Ban sudo systemctl start fail2ban 上述配置的意思是：600秒内5次尝试登陆ssh的IP地址会被判7200秒有期徒刑。\nFail2Ban常用命令:\n1 2 3 4 5 6 7 8 9 10 11 12 # 重启Fail2Ban sudo systemctl restart fail2ban # 查看fail2ban服务状态 sudo systemctl status fail2ban # 将Fail2Ban设为开机启动 sudo systemctl enable fail2ban # 查看状态 sudo fail2ban-client status # 查看sshd jail的详细状态 sudo fail2ban-client status sshd # 解禁指定IP sudo fail2ban-client set sshd unbanip 192.0.0.1 至此，VPS安全配置已经完成。接下开是真正的搭梯子环节。\nXRay安装与配置 不推荐用任何一键脚本，谁知道里边有没有藏什么东西。官方文档足够详细，安装配置足够简单。此部分详细内容可查阅官方文档。\nInstall Xray GitHub仓库Xray-install是Xray官方提供的安装方式，在仓库README页可以找到官方安装脚本：\n1 bash -c \u0026#34;$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)\u0026#34; @ install 后期更新新版本也是这个命令。\n一键安装，足够简单吧。\nConfig Xray 生成一个合法的 UUID 并保存备用（UUID可以简单粗暴的理解为像指纹一样几乎不会重复的 ID）。\n1 xray uuid 这个uuid要留存，后边配置会用到。\n修改Xray配置文件。\n1 sudo nano /usr/local/etc/xray/config.json 将以下内容粘贴进去。只需修改port和id两项。本文port以12345为例，id以上一步生成的为例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 # 原始版本，VMess+Kcp，访问不了ChatGPT客户端 { \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34;, \u0026#34;access\u0026#34;: \u0026#34;/var/log/xray/access.log\u0026#34;, // 这是 Linux 的路径 \u0026#34;error\u0026#34;: \u0026#34;/var/log/xray/error.log\u0026#34; }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 12345, // 服务器监听端口 \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, // 主传入协议 \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;0061c282-49f7-41d7-b223-0a9b6d8675dd\u0026#34;, // uuid，客户端与服务器必须相同 \u0026#34;alterId\u0026#34;: 0 } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;kcp\u0026#34;, //此处的 kcp 也可写成 mkcp，两种写法是起同样的效果 \u0026#34;kcpSettings\u0026#34;: { \u0026#34;uplinkCapacity\u0026#34;: 15, \u0026#34;downlinkCapacity\u0026#34;: 100, \u0026#34;congestion\u0026#34;: true, \u0026#34;readBufferSize\u0026#34;: 1, \u0026#34;writeBufferSize\u0026#34;: 1, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;wireguard\u0026#34; } } } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, // 主传出协议 \u0026#34;settings\u0026#34;: {} } ] } 开放在配置文件中指定的端口号。\n1 2 sudo ufw allow 12345/tcp comment \u0026#34;XRay\u0026#34; sudo ufw allow 12345/udp comment \u0026#34;XRay\u0026#34; 启动Xray\n1 2 3 4 5 6 # 启动XRay sudo systemctl start xray # 将XRay设为开机启动 sudo systemctl enable xray # 查看XRay运行状态 sudo systemctl status xray 看到下图这样绿色的active(running)就说明XRay已成功启动，这样服务端就配置好了。\n开启BBR加速。\n给 Debian 10 添加官方 backports 源，获取更新的软件库。\n1 sudo nano /etc/apt/sources.list 然后把下面这一条加在最后，并保存退出。\n1 deb http://archive.debian.org/debian buster-backports main 刷新软件库并查询 Debian 官方的最新版内核并安装。请务必安装你的 VPS 对应的版本（本文以比较常见的【amd64】为例）。\n1 sudo apt update \u0026amp;\u0026amp; sudo apt -t buster-backports install linux-image-amd64 修改 kernel 参数配置文件 sysctl.conf 并指定开启 BBR\n1 sudo nano /etc/sysctl.conf 把下面的内容添加进去\n1 2 net.core.default_qdisc=fq net.ipv4.tcp_congestion_control=bbr 重启 VPS、使内核更新和BBR设置都生效。\n1 sudo reboot 确认BBR开启。\n1 lsmod | grep bbr 此时应该返回tcp_bbr这样的结果。\n如果你想确认 fq 算法是否正确开启，可以使用下面的命令：\n1 lsmod | grep fq 此时应该返回sch_fq这样的结果。\n配置客户端。\n服务端配置结束，接下来就是在你的客户端进行配置。根据客户端用的代理工具不同，配置方法也不太一样。但全都是根据服务端的配置进行。主要是把IP:Port和uuid配置为与服务端一致。\n客户端配置就不细讲了。\n这样，就已经可以科学上网了。只是无法使用ChatGPT客户端，因为ChatGPT对这些VPS厂商的IP进行了封锁。\nWarp解锁ChatGPT ChatGPT封锁了VPS厂商的IP地址，而Cloudflare的Warp可以提供供我们使用的IP地址，所以我们用Warp提供的IP地址去访问ChatGPT。但是，Warp提供的IPv4地址已经被滥用，也无法访问ChatGPT客户端了，所以我们用Warp IPv6。目标是访问寻常网站时用VPS的公网IPv4地址，访问ChatGPT时用Warp的IPv6地址。\n执行下面这个脚本安装WGCF。\n1 wget -N https://gitlab.com/fscarmen/warp/-/raw/main/menu.sh \u0026amp;\u0026amp; bash menu.sh 根据需要选择语言，本文选中文了。\n因为我们这台VPS是IPv4 only的机器，没有IPv6地址，我们仅需要Warp提供IPv6地址，所以选择2. 为IPv4 only添加Warp IPv6网络接口。\n工作模式选1.全局（默认）即可。\n选择账户类型。这里根据自己的需要选择，我自己有WARP的团队版，即Zero Trust，所以选择3. Teams。\n接下来就是登陆选择的账户。Teams账户选择2.通过组织名和邮箱验证码来登陆是比较方便的。\n优先级别选择3.使用VPS初始设置（默认）即可。\n这样WGCF会开始安装，等待安装完成，运行下面的命令，可以看到有一个叫warp的网卡。\n1 sudo ifconfig 这样VPS就有IPv6地址了。\n修改XRay的配置文件\n1 sudo nano /usr/local/etc/xray/config.json 用下面的内容覆盖。将IPv4地址替换为你的VPS公网IPv4地址，将IPv6地址替换为warp网卡的地址。uuid和port也要替换为自己的。其他的不用更改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 # Warp接管IPv6流量版本，VMess+Kcp，解锁ChatGPT客户端 { \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34;, \u0026#34;access\u0026#34;: \u0026#34;/var/log/xray/access.log\u0026#34;, // 这是 Linux 的路径 \u0026#34;error\u0026#34;: \u0026#34;/var/log/xray/error.log\u0026#34; }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 12345, // 服务器监听端口 \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, // 主传入协议 \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;0061c282-49f7-41d7-b223-0a9b6d8675dd\u0026#34;, // uuID，客户端与服务器必须相同 \u0026#34;alterId\u0026#34;: 0 } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;kcp\u0026#34;, //此处的 kcp 也可写成 mkcp，两种写法是起同样的效果 \u0026#34;kcpSettings\u0026#34;: { \u0026#34;uplinkCapacity\u0026#34;: 15, \u0026#34;downlinkCapacity\u0026#34;: 100, \u0026#34;congestion\u0026#34;: true, \u0026#34;readBufferSize\u0026#34;: 1, \u0026#34;writeBufferSize\u0026#34;: 1, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;wireguard\u0026#34; } } } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, // 主传出协议 \u0026#34;settings\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;UseIPv4\u0026#34; }, \u0026#34;sendThrough\u0026#34;: \u0026#34;100.200.300.400\u0026#34; //VPS公网IPv4地址 }, { \u0026#34;tag\u0026#34;: \u0026#34;warp\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;UseIPv6\u0026#34; }, \u0026#34;sendThrough\u0026#34;: \u0026#34;2606:4700:110:88b8:5141:4387:4a3:20d1\u0026#34; //warp网卡IPv6地址 } ], \u0026#34;routing\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:openai\u0026#34;, \u0026#34;geosite:bing\u0026#34;, \u0026#34;geosite:netflix\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;warp\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; } ] } } 重启XRay，并确认Xray已成功运行。\n1 2 sudo systemctl start xray sudo systemctl status xray 在客户端连接该节点，可以发现ChatGPT客户端已经可以正常使用。\nReferences Project X官方文档 保护好你的小鸡！保姆级服务器安全教程！ vps 解锁 chatgpt 注册Cloudflare并加入ZeroTrust教程 ","date":"2024-09-18T16:26:03+08:00","permalink":"https://MasonCodingHere.github.io/p/build-your-own-ladder/","title":"私人代理——搭建专属于你的梯子"},{"content":"引言 继承是C++作为面向对象语言的一大特性。继承提高了代码的复用和可扩展性。子类可以把父类的数据成员“完整”地继承下来，而对于父类的成员函数，子类继承的是它们的调用权。 根据子类继承父类的个数，继承分为单继承、多继承：\n单继承，子类继承一个父类 多继承：子类继承多个父类 另外还有一种虚继承，虚继承其实是为了解决多继承带了的问题而引入的。后边再详述。 单继承没什么好说的，所以不单独列一节。并且下边的美人鱼例子，虽是为讲多继承而设计，但它也包含了单继承的内容。\n多继承 我们以美人鱼为例，美人鱼既有美人的某些属性，又有鱼的某些属性，可以把美人和鱼看作美人鱼的父类；而美人和鱼都是动物，可以把动物看作美人和鱼的共同父类。这样我们就可以定义如下几个类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Animal{ public: int data_Animal; }; class Beauty : public Animal{ public: int data_Beauty; }; class Fish : public Animal{ public: int data_Fish; }; class BeautyFish : public Beauty, public Fish{ public: int data_BeautyFish; }; 如果把这四个类的继承关系画成图，你就会发现，四个类组成一个菱形，这就是菱形继承。\n那么这四个类的对象会占用多大的内存呢？我在64位Linux平台下，用g++编译器的-fdump-class-hierarchy选项做了测试，为忽略内存对齐影响，使用#pragma pack(1)设为1字节对齐。测试结果如下：\n1 2 3 4 sizeof(Animal) == 4 sizeof(Beauty) == 8 sizeof(Fish) == 8 sizeof(BeautyFish) == 20 -fdump-class-hierarchy生成的文件内容如下（只保留以上四个类）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Class Animal size=4 align=1 base size=4 base align=1 Animal (0x0x7f11187c4d80) 0 Class Beauty size=8 align=1 base size=8 base align=1 Beauty (0x0x7f111860e5b0) 0 Animal (0x0x7f11187c4de0) 0 Class Fish size=8 align=1 base size=8 base align=1 Fish (0x0x7f111860e618) 0 Animal (0x0x7f11187c4e40) 0 Class BeautyFish size=20 align=1 base size=20 base align=1 BeautyFish (0x0x7f111861e540) 0 Beauty (0x0x7f111860e680) 0 Animal (0x0x7f11187c4ea0) 0 Fish (0x0x7f111860e6e8) 8 Animal (0x0x7f11187c4f00) 8 这是一个简单的模型，各个类都没有虚函数，所以不难想象为什么结果是这样。用图来表示，各个类的对象的内存布局大致如下：\n可以看到，在BeautyFish的对象内，保存了两份data_Animal，一份来自父类Beauty，另一份来自父类Fish。从功能上讲，BeautyFish的对象没有必要保存两份data_Animal，这样是非常浪费内存空间的，这就是多继承带来的数据冗余问题。\n除了数据冗余，多继承还会带来二义性问题。假设有下面这样的程序：\n1 2 3 4 5 6 int main(){ BeautyFish bf; bf.data_Animal = 2021; //语句1 bf.Beauty::data_Animal = 2021; //语句2 bf.Fish::data_Animal = 2021; //语句3 } 语句1将会产生二义性调用，bf内有两份data_Animal，程序不知道该去给哪一个进行赋值操作； 语句2和语句3可以正常通过，因为通过作用域限定符指明了具体给哪个data_Animal进行赋值操作。 虚继承 为了解决多继承带来的数据冗余与二义性问题，C++引入了虚继承机制。虚继承使子类只保留一份间接基类的成员，既节省内存空间，又避免了二义性的麻烦。\n于BeautyFish类而言，Beauty和Fish是它的直接基类，Animal则是它的间接基类。\n具体做起来也非常简单，只需要在Beauty和Fish继承Animal时，加一个virtual关键字。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Animal{ public: int data_Animal; }; class Beauty : public virtual Animal{ public: int data_Beauty; }; class Fish : public virtual Animal{ public: int data_Fish; }; class BeautyFish : public Beauty, public Fish{ public: int data_BeautyFish; }; 同样的方法，我们再来测一下四个类的对象的大小，测试结果如下：\n1 2 3 4 sizeof(Animal) == 4 sizeof(Beauty) == 16 sizeof(Fish) == 16 sizeof(BeautyFish) == 32 -fdump-class-hierarchy生成的文件内容如下（只保留以上四个类）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 Class Animal size=4 align=1 base size=4 base align=1 Animal (0x0x7f758e638d80) 0 Vtable for Beauty Beauty::_ZTV6Beauty: 3u entries 0 12u 8 (int (*)(...))0 16 (int (*)(...))(\u0026amp; _ZTI6Beauty) VTT for Beauty Beauty::_ZTT6Beauty: 1u entries 0 ((\u0026amp; Beauty::_ZTV6Beauty) + 24u) Class Beauty size=16 align=1 base size=12 base align=1 Beauty (0x0x7f758e4825b0) 0 vptridx=0u vptr=((\u0026amp; Beauty::_ZTV6Beauty) + 24u) Animal (0x0x7f758e638de0) 12 virtual vbaseoffset=-24 Vtable for Fish Fish::_ZTV4Fish: 3u entries 0 12u 8 (int (*)(...))0 16 (int (*)(...))(\u0026amp; _ZTI4Fish) VTT for Fish Fish::_ZTT4Fish: 1u entries 0 ((\u0026amp; Fish::_ZTV4Fish) + 24u) Class Fish size=16 align=1 base size=12 base align=1 Fish (0x0x7f758e482618) 0 vptridx=0u vptr=((\u0026amp; Fish::_ZTV4Fish) + 24u) Animal (0x0x7f758e638e40) 12 virtual vbaseoffset=-24 Vtable for BeautyFish BeautyFish::_ZTV10BeautyFish: 6u entries 0 28u 8 (int (*)(...))0 16 (int (*)(...))(\u0026amp; _ZTI10BeautyFish) 24 16u 32 (int (*)(...))-12 40 (int (*)(...))(\u0026amp; _ZTI10BeautyFish) Construction vtable for Beauty (0x0x7f758e482680 instance) in BeautyFish BeautyFish::_ZTC10BeautyFish0_6Beauty: 3u entries 0 28u 8 (int (*)(...))0 16 (int (*)(...))(\u0026amp; _ZTI6Beauty) Construction vtable for Fish (0x0x7f758e4826e8 instance) in BeautyFish BeautyFish::_ZTC10BeautyFish12_4Fish: 3u entries 0 16u 8 (int (*)(...))0 16 (int (*)(...))(\u0026amp; _ZTI4Fish) VTT for BeautyFish BeautyFish::_ZTT10BeautyFish: 4u entries 0 ((\u0026amp; BeautyFish::_ZTV10BeautyFish) + 24u) 8 ((\u0026amp; BeautyFish::_ZTC10BeautyFish0_6Beauty) + 24u) 16 ((\u0026amp; BeautyFish::_ZTC10BeautyFish12_4Fish) + 24u) 24 ((\u0026amp; BeautyFish::_ZTV10BeautyFish) + 48u) Class BeautyFish size=32 align=1 base size=28 base align=1 BeautyFish (0x0x7f758e492540) 0 vptridx=0u vptr=((\u0026amp; BeautyFish::_ZTV10BeautyFish) + 24u) Beauty (0x0x7f758e482680) 0 primary-for BeautyFish (0x0x7f758e492540) subvttidx=8u Animal (0x0x7f758e638ea0) 28 virtual vbaseoffset=-24 Fish (0x0x7f758e4826e8) 12 subvttidx=16u vptridx=24u vptr=((\u0026amp; BeautyFish::_ZTV10BeautyFish) + 48u) Animal (0x0x7f758e638ea0) alternative-path 虽然只是加了个virtual，但我们可以看到上边的文件已经比之前的复杂很多了。经过分析上边的文件，结合gdb的打印类布局的内容以及网上相关博客，我还是分析出了四个类的内存布局。\nAnimal、Beauty和Fish的内存模型如下图：\nAnimal类对象的内存布局与之前一模一样，不再赘述。\nBeauty和Fish内存模型是一样的，我们以Beauty为例讲解。\n虚继承的话，子类的对象里首先存的是自己的东西，最后才是虚基类的东西； 非虚继承的话，子类的对象里首先存的是基类的东西，最后才是自己的东西。如果有多个基类，则按照继承的顺序，第一个基类被设为主基类。 由于是Beauty虚继承Animal，所以在Beauty对象的内存里，首先是虚指针vptr和Beauty自己的数据data_Beauty，最后才是从虚基类Animal继承来的data_Animal。\nBeauty的虚表有三个内容：\n第一个slot是vbase_offset，其值是12。这个值的意思是，Beauty中虚基类的部分（即Animal的部分）在Beauty对象内存中的偏移量是12。我们可以看到从Beauty对象的内存首地址偏移12个字节正好是data_Animal的地址。 第二个slot是offset_to_top。将对象从当前这个类型（this指针）转换为该对象的实际类型的地址偏移量； 第三个slot是type_info_for_Beauty,用于RTTI。 第二和第三个slot里的内容还没有弄明白，这里就先不多说了。\nBeautyFish就比较复杂了，其内存布局大致如下：\nBeautyFish非虚继承Beauty和Fish，所以BeautyFish对象的内存里，首先是基类的东西，即Beauty的虚指针和数据、Fish的虚指针和数据，然后是BeautyFish自己的数据，最后是虚基类Animal的数据。\nBeautyFish的虚表这里不再展开。\n总结 关于C++对象的内存布局，C++标准并没有作出严格的约束，只是做了一个框架性的约束，而具体的实现交由编译器自己来完成。所以就导致C++对象模型相关内容是编译器相关的，不同的编译器可能会有不同的结果。\n以我所知道的，GCC和VC++对于C++对象内存模型的实现差别就很大。比如对于虚基类，GCC的做法是扩展了虚表（virtual table）；而VC++则是模仿虚表，建了一个虚基类表（virtual base class table），正如虚指针vptr指向虚表一样，VC++会在C++对象里加一个虚基类指针vbptr，该指针指向虚基类表。\n这些东西有些繁杂，我也不能保证写的一定正确，很多东西都是自己分析得出，只为建立自己的C++对象模型观。如有朋友发现有误，欢迎指出。\n","date":"2021-06-22T06:19:43-07:00","permalink":"https://MasonCodingHere.github.io/p/cpp-multiple-inheritance/","title":"美人+鱼=美人鱼——谈C++多继承"},{"content":"引言 Echo客户端/服务端程序应该是网络编程领域的入门首选，可以视为网络编程领域的HelloWorld程序。\n为了深入学习网络编程，我写了这样一个程序，姑且叫它Simplest_Socket。这确实是最简单的socket通信程序。与一般的Echo服务器不同，Simplest_Socket会把客户端传来的英文字符串转换为大写再返回给客户端；而不像Echo服务器那样原样返回。\n这样设计的目的在于体现服务器的“服务”功能，尽管只是把小写转为大写，但这确实是一项服务。\n思路 TCP套接字通信由一个四元组确定一个端到端通信，即：\n（客户端IP地址，客户端端口号，服务端IP地址，服务端端口号）\n整体的时序图如下：\n上图中数据传输采用了read/write函数，套接字是一种文件类型，所以用这两个文件IO来读写套接字描述符也可以；但是套接字与普通文件又有些不同，在\u0026lt;sys/socket.h\u0026gt;中声明了专门用于socket的IO函数：send函数和recv函数。Simplest_Socket采用这两个函数来读写套接字。\n客户端 指定服务端套接字地址结构 客户端作为连接的主动发起方，它需要知道它要连到哪个服务器的哪个端口，所以在客户端程序中，首先要定义服务端的套接字地址结构，在IPv4因特网中，套接字地址结构由结构体sockaddr_in定义，它声明在头文件\u0026lt;arpa/inet.h\u0026gt;中。在这个结构体中：\nsin_family用于指定使用的网络层协议IPv4，取值为AF_INET； in_port_t被定义为uint16_t，sin_port指定端口号，由于是无符号16位整型，所以其取值范围为0~65535； sin_addr用于指定IPv4地址，它也是一个结构体in_addr，in_addr_t被定义为uint32_t，即无符号32位整型，正好与IPv4地址的大小对应。 1 2 3 4 5 6 7 8 9 #include \u0026lt;arpa/inet.h\u0026gt; struct in_addr{ in_addr_t s_addr; //IPv4地址 }; struct sockaddr_in{ sa_family_t sin_family; //协议族 in_port_t sin_port; //端口号 struct in_addr sin_addr; //IPv4地址 } 我们所定义的存放IP地址和端口号的变量均已主机字节序存放在我们的本地主机上，当进行网络通信时，需要将它们转化为网络字节序，这些工作由头文件\u0026lt;arpa/inet.h\u0026gt;中声明的htons函数和inet_pton函数来完成：\nhtons函数用于把将无符号16位整型数据由主机字节序转为网络字节序，端口号正好适用； inet_pton函数用于将主机字节序的点分十进制IP地址转换为网络字节序的二进制IP地址，IPv4地址和IPv6地址均可用该函数。 1 2 3 4 5 #include \u0026lt;arpa/inet.h\u0026gt; uint16_t htons(uint16_t hostint16); int inet_pton(int domain, const char *restrict str, void *restrict addr); 所以对于我们的客户端，我们可以定义如下套接字地址结构：\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;string.h\u0026gt; const char* server_ip = \u0026#34;127.0.0.1\u0026#34;; //服务端IP地址 const uint16_t SERVER_PORT = 2021; //服务端监听端口号 struct sockaddr_in server_sockaddr; memset(\u0026amp;server_sockaddr, 0, sizeof(server_sockaddr)); server_sockaddr.sin_family = AF_INET; //指定IPv4 server_sockaddr.sin_port = htons(SERVER_PORT); inet_pton(AF_INET, server_ip, \u0026amp;server_sockaddr.sin_addr); 声明在\u0026lt;string.h\u0026gt;中的memset函数可以用于初始化新申请的空间，将其置为指定值。\n创建套接字 既然要使用套接字，当然第一件事就是调用socket函数创建套接字。\n1 2 3 #include \u0026lt;sys/socket.h\u0026gt; int socket(int family, int type, int protocol); //成功返回非负套接字描述符，出错返回-1 对于我们的客户端：\nfamily：设置协议域为AF_INET，即IPv4； type：设置套接字类型为SOCK_STREAM，即字节流套接字； protocol：设置该参数为0，表示选择根据family和type组合系统提供的默认传输层协议。对于AF_INET和SOCK_STREAM组合，默认协议为TCP。 使用perror函数将错误原因输出到标准错误（stderr）：\n1 2 3 #include \u0026lt;stdio.h\u0026gt; void perror(const char *str); //输出格式为\u0026#34;str:错误原因\u0026#34;,错误原因依照全局变量errno的值来决定要输出的字符串 所以在客户端中这样创建客户端的套接字：\n1 2 3 4 5 6 7 8 #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int client_fd = socket(AF_INET, SOCK_STREAM, 0); //指定TCP协议 if(client_fd \u0026lt; 0){ perror(\u0026#34;socket\u0026#34;); exit(1); } 发起连接 创建完套接字之后，作为主动方的客户端要做的就是发起连接，这由connect函数完成：\n1 2 3 #include \u0026lt;sys/socket.h\u0026gt; int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen); //成功返回0；出错返回-1 sockfd参数即客户端socket函数返回的套接字描述符； servaddr参数指向一个指明了服务端IP地址和端口号的套接字地址结构，即我们之前创建的server_sockaddr； addrlen参数是servaddr参数指向的地址结构的大小，可由sizeof()运算得到。 所以，在客户端中这样发起连接：\n1 2 3 4 5 6 7 #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; if(connect(client_fd, (struct sockaddr*) \u0026amp;server_sockaddr, sizeof(server_sockaddr)) \u0026lt; 0){ perror(\u0026#34;connect\u0026#34;); exit(1); } 调用connect函数将激发TCP的三路握手过程，详情以后分析TCP状态机的时候再讲。\n数据传输 客户端发起连接之后，服务端接收连接，双方完成TCP的三路握手之后，通信链路就建立起来了，客户端可以传输数据了。\n在传输数据之前，我们定义了一个发送缓冲区sendbuf和一个接收缓冲区recvbuf。\n对于Simplest_Socket来说，客户端传输的数据就是用户输入的英文字符串，所以while函数的条件我们设置为fgets函数，fgets函数是一个声明在\u0026lt;stdio.h\u0026gt;的标准IO库函数：\n1 2 3 #include \u0026lt;stdio.h\u0026gt; char *fgets(char *restrict buf, int n, FILE *restrict fp); //成功返回buf；若已到达文件尾或出错返回NULL fgets函数从指定的流fp读取字符送到长度为n的缓冲区buf，一直读到下一个换行符为止，但不会超过n-1个字符。 fgets函数：缓冲区buf以null字节结尾。如果该行（包括换行符）的字符数超过n-1，则fgets只返回一个不完整的行，但是buf总是以null结尾。对fgets的下一次调用会继续读该行。\n我们从标准输入（stdin）读取用户输入的数据到sendbuf。然后就可以使用send函数把sendbuf中的数据通过客户端的套接字传输给服务端，\n1 2 3 #include \u0026lt;sys/socket.h\u0026gt; ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags); //成功返回发送的字节数；出错返回-1 send函数将buf中的nbytes个字节的数据通过套接字描述符sockfd发送给服务端，flags参数一般置0。 我们可以用strlen函数获取sendbuf中实际数据的长度：\n1 size_t strlen(const char* str); strlen函数从字符串的开头位置依次向后计数，直到遇见\\0，然后返回计时器的值。最终统计的字符串长度不包括\\0。 我们定义如果用户输入的是Q\\n，表示退出。这个用strcmp函数来完成：\n1 2 #include \u0026lt;string.h\u0026gt; int strcmp(const char *str1, const char *str2) strcmp函数返回值为0则表示参与比较的两个字符串相等。 发送完数据之后要做的就是要接收服务端返回的数据，这由recv函数来完成：\n1 2 3 #include \u0026lt;sys/socket.h\u0026gt; ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags); //返回值：返回数据的字节长度；若无可用数据或对等方已经按序结束，返回0；出错返回-1 recv函数通过套接字描述符sockfd接收数据至buf，nbytes参数指定buf的大小，flags参数一般置0。 接收完数据后，通过fputs函数把recvbuf的内容输出到标准输出（stdout）。\n1 2 #include \u0026lt;stdio.h\u0026gt; int fputs(const char *restrict str, FILE *restrict fp); fputs函数将一个以null字节终止的字符串str写到指定的流fp，尾端的终止符null不写出。 在准备发送和接收下一次的新数据之前，我们用memset函数将sendbuf和recvbuf的空间全部置0：\n1 2 #include \u0026lt;string.h\u0026gt; void *memset(void *str, int c, size_t n) memset函数将参数 str 所指向的字符串的前 n 个字符置为值c。 所以在客户端这样写数据传输部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;string.h\u0026gt; const int BUFFER_SIZE = 1024; //定义缓冲区大小 char sendbuf[BUFFER_SIZE]; char recvbuf[BUFFER_SIZE]; while(fgets(sendbuf, sizeof(sendbuf), stdin)){ //从stdin读入待传输数据至sendbuf send(client_fd, sendbuf, strlen(sendbuf), 0); //将sendbuf中的数据通过client_fd套接字传输 if(strcmp(sendbuf, \u0026#34;Q\\n\u0026#34;) == 0) //输入Q表示退出 break; recv(client_fd, recvbuf, sizeof(recvbuf), 0); //从client_fd套接字接收数据，保存至recvbuf fputs(recvbuf, stdout);//将recvbuf中的数据输出至stdout memset(sendbuf, 0, sizeof(sendbuf));//将sendbuf的内存值置0 memset(recvbuf, 0, sizeof(recvbuf));//将recvbuf的内存值置0 } 关闭连接 当用户输入Q\\n，表示要退出连接。\n因为套接字也是一种文件类型，所以我们可以像关闭普通的文件描述符一样，用close函数来关闭它。\n1 2 3 #include \u0026lt;unistd.h\u0026gt; int close(int fd); //成功返回0；出错返回-1 所以在客户端这样写关闭连接部分：\n1 2 3 #include \u0026lt;unistd.h\u0026gt; close(client_fd); 服务端 服务端部分内容与客户端一致，重复部分不再赘述。\n定义服务端套接字地址结构 这一部分与客户端相同，也是定义服务端的套接字地址结构。\n创建监听套接字 服务端作为被动接收连接的一方，需要创建一个监听套接字，这个也跟客户端创建套接字一样。\n绑定 对于服务端，我们一般还会指定一个固定的端口号，并且这个端口号还应该让想用这个服务器的客户端知道，也就是服务端的监听套接字要绑定一个固定的套接字地址结构，这样客户端在想要连接到这个服务端时，才可以知道我应该连接到哪个套接字地址结构，如果你的端口号一直变，那客户端就比较难受了。\n这个绑定工作由bind函数完成。\n1 2 3 #include \u0026lt;sys/socket.h\u0026gt; int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen); //成功返回0；出错返回-1 bind函数将套接字sockfd绑定到套接字地址结构myaddr，addrlen为myaddr的长度，可由sizeof()得到。 转化为被动套接字 由socket函数创建的套接字是一个主动套接字，即它是一个会调用connect函数发起连接的客户端套接字。\n那问题就出来了，我服务端的套接字可不是要主动发起连接的，而是要被动接受连接的。那么就需要把socket函数创建的主动套接字转化为被动套接字，这个工作由listen函数来完成：\n1 2 3 #include \u0026lt;sys/socket.h\u0026gt; int listen(int sockfd, int backlog); //成功返回0；出错返回-1 listen函数把主动套接字sockfd转化为被动套接字，指示内核应该接受指向该套接字的连接请求。 backlog参数规定了内核应该为sockfd套接字排队的最大连接个数。 调用listen函数会使TCP服务器状态由ClOSED转为LISTEN。\n接收请求 接下来就是接收客户端的连接请求，该工作由accept函数完成。\n1 2 #include \u0026lt;sys/socket.h\u0026gt; int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen); accept函数接收监听套接字描述符，并返回一个已连接套接字描述符。 cliaddr参数和addrlen用于返回客户的套接字地址结构及其大小，若不关心客户端的身份，将二者设为NULL即可。 数据传输 数据传输过程也与客户端没有太大不同。\n关闭连接 关闭连接也与客户端相同，只是服务端要关闭两个套接字：\n监听套接字 已连接套接字 源程序 客户端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;sys/socket.h\u0026gt; //socket系列函数头文件 #include \u0026lt;arpa/inet.h\u0026gt; //sockaddr_in结构体、inet_pton函数和htons函数头文件 #include \u0026lt;string.h\u0026gt; //strlen函数、strcmp函数和memset函数头文件 #include \u0026lt;unistd.h\u0026gt; //close函数头文件 #include \u0026lt;stdlib.h\u0026gt; //exit函数头文件 #include \u0026lt;stdio.h\u0026gt; //fgets函数、fputs函数、perror函数头文件 const int BUFFER_SIZE = 1024; //定义缓冲区大小 const char* server_ip = \u0026#34;127.0.0.1\u0026#34;; //服务端IP地址 const uint16_t SERVER_PORT = 2021; //服务端监听端口号 int main(){ //定义服务端套接字地址结构 struct sockaddr_in server_sockaddr; memset(\u0026amp;server_sockaddr, 0, sizeof(server_sockaddr)); server_sockaddr.sin_family = AF_INET; //指定IPv4 server_sockaddr.sin_port = htons(SERVER_PORT); inet_pton(AF_INET, server_ip, \u0026amp;server_sockaddr.sin_addr); //创建客户端套接字描述符 int client_fd = socket(AF_INET, SOCK_STREAM, 0); //指定TCP协议 if(client_fd \u0026lt; 0){ perror(\u0026#34;socket\u0026#34;); exit(1); } //发起连接 if(connect(client_fd, (struct sockaddr*) \u0026amp;server_sockaddr, sizeof(server_sockaddr)) \u0026lt; 0){ perror(\u0026#34;connect\u0026#34;); exit(1); } //开始数据传输 char sendbuf[BUFFER_SIZE]; char recvbuf[BUFFER_SIZE]; while(fgets(sendbuf, sizeof(sendbuf), stdin)){ //从stdin读入待传输数据至sendbuf send(client_fd, sendbuf, strlen(sendbuf), 0); //将sendbuf中的数据通过client_fd套接字传输 if(strcmp(sendbuf, \u0026#34;Q\\n\u0026#34;) == 0) //输入Q表示退出 break; recv(client_fd, recvbuf, sizeof(recvbuf), 0); //从client_fd套接字接收数据，保存至recvbuf fputs(recvbuf, stdout);//将recvbuf中的数据输出至stdout memset(sendbuf, 0, sizeof(sendbuf));//将sendbuf的内存值置0 memset(recvbuf, 0, sizeof(recvbuf));//将recvbuf的内存值置0 } //关闭连接 close(client_fd); return 0; } 服务端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026lt;sys/socket.h\u0026gt; //socket系列函数头文件 #include \u0026lt;arpa/inet.h\u0026gt; //sockaddr_in结构体、inet_pton函数、htons函数头文件 #include \u0026lt;string.h\u0026gt; //strlen函数、strcmp函数和memset函数头文件 #include \u0026lt;unistd.h\u0026gt; //close函数头文件 #include \u0026lt;stdlib.h\u0026gt; //exit函数头文件 #include \u0026lt;stdio.h\u0026gt; //perror函数头文件 #include \u0026lt;ctype.h\u0026gt; //toupper函数头文件 const char* server_ip = \u0026#34;127.0.0.1\u0026#34;; //指定服务端IP地址 const uint16_t SERVER_PORT = 2021;//指定监听端口号 const int QUEUE = 1024; //用于listen函数第二个参数，指定内核应为相应套接字排队的最大连接数 const int BUFFER_SIZE = 1024;//指定缓冲区大小 int main(){ //定义服务端套接字地址结构并赋值 struct sockaddr_in server_sockaddr; memset(\u0026amp;server_sockaddr, 0, sizeof(server_sockaddr)); server_sockaddr.sin_family = AF_INET; //指定IPv4 server_sockaddr.sin_port = htons(SERVER_PORT); inet_pton(AF_INET, server_ip, \u0026amp;server_sockaddr.sin_addr); //创建一个监听套接字描述符 int listen_fd = socket(AF_INET, SOCK_STREAM, 0); //指定TCP协议 if(listen_fd \u0026lt; 0){ perror(\u0026#34;socket\u0026#34;); exit(1); } //将监听套接字描述符绑定到套接字地址结构 if(bind(listen_fd, (struct sockaddr*) \u0026amp;server_sockaddr, sizeof(server_sockaddr)) \u0026lt; 0){ perror(\u0026#34;bind\u0026#34;); exit(1); } //开始监听 if(listen(listen_fd, QUEUE) \u0026lt; 0){ perror(\u0026#34;listen\u0026#34;); exit(1); } //接受连接请求，创建 已连接套接字描述符 int conn_fd = accept(listen_fd, NULL, NULL); if(conn_fd \u0026lt; 0){ perror(\u0026#34;accept\u0026#34;); exit(1); } //开始数据传输 char sendbuf[BUFFER_SIZE]; char recvbuf[BUFFER_SIZE]; while(1){ memset(recvbuf, 0, sizeof(recvbuf)); memset(sendbuf, 0, sizeof(sendbuf)); recv(conn_fd, recvbuf, sizeof(recvbuf), 0); //从conn_fd套接字接收数据，保存至recvbuf if(strcmp(recvbuf, \u0026#34;Q\\n\u0026#34;) == 0) //如果收到的数据是Q，表示退出 break; fputs(recvbuf, stdout); //将收到的数据原样输出至stdout //将recvbuf中的小写字母转为大写，新数据保存至sendbuf for(int i = 0; i \u0026lt; strlen(recvbuf); ++i){ if(islower(recvbuf[i])) sendbuf[i] = toupper(recvbuf[i]); else sendbuf[i] = recvbuf[i]; } send(conn_fd, sendbuf, strlen(sendbuf), 0); //将sendbuf中的数据通过conn_fd套接字传输 } //关闭连接及监听描述符 close(conn_fd); close(listen_fd); return 0; } 数据流通图 ","date":"2021-05-14T06:44:38-07:00","permalink":"https://MasonCodingHere.github.io/p/helloworld-on-network-programming/","title":"网络编程领域的HelloWorld程序"}]