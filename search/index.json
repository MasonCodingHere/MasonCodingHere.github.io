[{"content":"new expression 分配内存-调用构造函数-返回指针\nThe new operator is an operator which denotes a request for memory allocation on the Heap. If sufficient memory is available, new operator initializes the memory and returns the address of the newly allocated and initialized memory to the pointer variable. When you create an object of class using new keyword(normal new).\nThe memory for the object is allocated using operator new from heap. The constructor of the class is invoked to properly initialize this memory. operator new 只分配内存-返回指针/抛出异常\nOperator new is a function that allocates raw memory and conceptually a bit similar to malloc().\nIt is the mechanism of overriding the default heap allocation logic. It doesn’t initializes the memory i.e constructor is not called. However, after our overloaded new returns, the compiler then automatically calls the constructor also as applicable. It’s also possible to overload operator new either globally, or for a specific class New operator vs operator new Operator vs function: new is an operator as well as a keyword whereas operator new is only a function. New calls “Operator new”: “new operator” calls “operator new()” , like the way + operator calls operator +() “Operator new” can be Overloaded: Operator new can be overloaded just like functions allowing us to do customized tasks. Memory allocation: ‘new expression’ call ‘operator new’ to allocate raw memory, then call constructor. References ","date":"2024-09-30T09:52:09+08:00","image":"https://raw.githubusercontent.com/MasonCodingHere/MasonHugoBlogPics1/main/DefaultImg/DefaultPostImg1.jpg","permalink":"https://MasonCodingHere.github.io/p/things-about-new/","title":"C++ new那些事儿"},{"content":"前言 本文待完善。\n整体思路 使用Hugo作为博客框架，在本地编写Markdown文件，构成博客站点源码库。将源码库上传至GitHub仓库MasonHugoBlog，并设置GitHub Action，由GitHub Action运行hugo命令生成博客HTML文件并上传至MasonCodingHere.github.io，最终由GitHub Pages完成部署。\n所以需要两个GitHub仓库。\nMasonHugoBlog：用于存储站点源码。 MasonCodingHere.github.io：用于存储生成的HTML文件。 Hugo安装与配置 参考Hugo官方文档，根据操作系统选择安装方式。本文以macOS为例。\n前提 Hugo依赖Git和Go，所以要先安装这两个。\n不展开讲了。\n安装hugo 本文采用Homebrew的安装方式\n1 brew install hugo 安装结束，执行以下命令，看到版本号说明安装成功。\n1 hugo version 新建站点 在你希望的位置执行下面的命令，新建一个Hugo站点。\n1 hugo new site MasonHugoBlog 这样会出现一个名为MasonHugoBlog的文件夹，这就是博客源码。\n选择主题 在官方主题库选择一个主题，当然也可以去GitHub找官方主题库里没有的主题。本文选择Stack主题。\n本文选择Git Submodule的方式安装。\n1 2 3 cd MasonHugoblog git init git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack 这样theme文件夹下就会出现该主题。我想让我的博客跟Stack主题提供的Demo站点一样，所以做了一下事情。\n把MasonHugoblog/themes/Hugo-theme-stack/exampleSite/content/下的内容复制到MasonHugoblog/content/。 删除MasonHugoblog/hugo.toml，把MasonHugoblog/themes/Hugo-theme-stack/Hugo.yaml复制到MasonHugoblog/。 这样执行以下命令，在本地预览，发现已经跟Demo一致。\n1 hugo server -D 配置博客 各种个性化配置，包括该博客名称、换头像、改链接、去除自己不需要的多语言支持等等，在hugo.yaml中配置。\n删除默认博文、删除默认分类和标签、修改博文默认模版等等。\n不展开说了。\nGitHub Actions Push to GitHub 接下来就是把整个文件夹推到GitHub，在GitHub新建一个仓库MasonHugoBlog。把本地的MasonHugoBlog文件夹推到这个仓库。不细说了。\n之后，因为我们以后写文章、更新博客，都是要推这个文件夹，所以写一个脚本更方便，在MasonHugoBlog下新建一个名为deploy.sh的脚本文件，把以下内容复制粘贴过去。这样以后写完md文件，直接执行./deploy.sh就完成部署了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #!/bin/bash # Check if the directory /public exists if [ -d \u0026#34;./public\u0026#34; ]; then # If it exists, delete the directory rm -rf ./public echo \u0026#34;./public directory has been deleted.\u0026#34; else # If it doesn\u0026#39;t exist, print a message echo \u0026#34;./public directory does not exist.\u0026#34; fi # Check if a commit message was provided as an argument if [ -z \u0026#34;$1\u0026#34; ]; then # If no commit message is provided, use the current date and time COMMIT_MSG=\u0026#34;Update at $(date)\u0026#34; else # Use the provided commit message COMMIT_MSG=\u0026#34;$1\u0026#34; fi # Add all changes git add . # Commit changes with the provided message git commit -m \u0026#34;$COMMIT_MSG\u0026#34; # Push changes to the \u0026#39;main\u0026#39; branch git push origin main # Print a success message echo \u0026#34;Changes have been pushed to GitHub successfully!\u0026#34; 因为我们想这个库只保存源码，所以生成的静态HTML文件我们不要，所以在上传之前先检测有无/public文件夹，有的话删掉再上传。\nDeploy Key 在本地用sshkeygen生成一对key\n公钥给MasonCodingHere.github.io的Deploy key\n私钥给MasonHugoBlog的Actions的secrets。\nMasonHugoBlog的Workflow permissions改为Read and write permissions\nGitHub Actions 给MasonHugoBlog添加Actions\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 name: Deploy Hugo to GitHub Pages on: push: branches: - main # Trigger deployment when changes are pushed to the main branch jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout the repository uses: actions/checkout@v2 with: submodules: true - name: Set up Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.134.2\u0026#39; extended: true - name: Build the website run: hugo - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.DEPLOY_KEY }} publish_dir: ./public # This is the directory where Hugo generates static files external_repository: MasonCodingHere/MasonCodingHere.github.io publish_branch: main GitHub图床 每个repo有1G的大小限制，如果把图片也传到博客仓库，很快就会满。\n在GitHub新建一个图床库PicsBed_1\n生成一个Token，选public_repo\n安装PicGo，设置Token。\n为PicsBed_1添加Actions如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 name: Update README with Directory Structure on: push: branches: - main jobs: update-readme: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v2 - name: Generate directory structure run: | echo \u0026#34;# Directory Structure\u0026#34; \u0026gt; structure.txt echo \u0026#34;\\`\\`\\`\u0026#34; \u0026gt;\u0026gt; structure.txt tree -I \u0026#34;.git|node_modules|structure.txt\u0026#34; \u0026gt;\u0026gt; structure.txt echo \u0026#34;\\`\\`\\`\u0026#34; \u0026gt;\u0026gt; structure.txt - name: Update README run: | cat structure.txt \u0026gt; README.md - name: Commit changes run: | git config --local user.name \u0026#34;GitHub Action\u0026#34; git config --local user.email \u0026#34;action@github.com\u0026#34; git add README.md git commit -m \u0026#34;Update directory structure in README\u0026#34; git push env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} References Hugo官方文档 Stack主题官方网站 Stack主题官方GitHub仓库 图片上传工具PicGo官网 图片上传工具PicGo官方GitHub仓库 ","date":"2024-09-20T15:18:02+08:00","image":"https://www.adamormsby.com/posts/000/how-to-set-up-a-hugo-site-on-github-pages-with-submodules/cover.jpg","permalink":"https://MasonCodingHere.github.io/p/build-your-blog/","title":"Hugo + GitHub Pages搭建个人博客"},{"content":"前言 大家都知道，像Google、Twitter这类的海外网站在中国大陆是无法直接访问的。大家还知道，连上VPN就可以访问这些网站了。至于其中的细节，大多数人就不知道了，确实也没必要知道。但是有一点我们要明白，VPN能够起到效果的重要原因是GFW没有封锁一切海外网站。正是由于这个原因，我们才能有空子可钻。\n技术上讲，VPN≠翻墙。不过在大陆VPN已经成为翻墙的代名词，这里就不咬文嚼字了。\n在互联网中，IP地址是我们的“身份证”。这些被禁的海外网站也有自己的IP地址，可惜被墙了，所以我们无法直接访问。还存在一些IP地址，没有被墙，我们可以访问。一系列的翻墙技术正是建立在这个基础上。\n假设有这样一个IP地址A，A没有被GFW墙掉，并且A作为互联网的一员，可以访问那些被墙的网站。我们可以把要访问Google的请求发给A，由A帮我们访问，再把结果发给我们，这就是代理的原理，也是一系列翻墙技术得以实现的基础。\n购买VPS 我们需要一个没有被墙的IP地址，购买一台海外VPS可以满足这个需求。VPS其实就是一台位于海外的云服务器。\n有很多VPS厂商，比如BandWagon、Vultr、CloudCone等等，本文以Vultr为例，其他的厂商也大同小异。\n注册并登陆Vultr，点击右上角的Deploy按钮按以下步骤部署一台VPS。\n选择VPS类型和位置 类型选Shared CPU即可。\n位置看自己需求，这里以美国Los Angeles为例。\n选择系统镜像 选一个操作系统，服务器嘛，自然是要选Linux，推荐选择Debian，比较稳定。\n选择Plan 根据需求，选择一个配置，配置越高越贵。这里选择最便宜的5$/month的Plan。\n其他设置 去掉Auto Backups，费钱。\n去掉IPv6，不需要。\n这里可以把SSH key上传一下，把本地电脑~/.ssh/的公钥传到Vultr，这样等部署完可以直接密钥登陆，不用输密码，方便很多。\n在Server Hostname设置一下主机名，自己起个名即可，本文以Test为例。\n下单 这样就配好了，确认一下数量和价格，点击Deploy Now就开始部署了。\n部署过程或许需要几分钟，耐心等待一下。\n部署完成 Status变成Running就部署完成了，打码处为这台VPS的公网IP地址，下文以100.200.300.400来表示。\n检查IP是否被墙 在站长工具-Ping检测输入你的IP地址，点击Ping检测，如果大部分是绿的，说明IP没被墙，可以放心使用。\n如果全是红色，说明此IP地址已被墙，无法使用，根据你的VPS厂商政策，想办法更换IP，直至可用。\n配置VPS SSH登陆VPS 要配置VPS，首先通过SSH登陆VPS。打开你的终端工具，输入以下命令登陆VPS。\n1 ssh root@100.200.300.400 SSH登陆Linux服务器是基本操作，不细说了。\n启用ufw防火墙 登陆后第一件事，就是启用ufw防火墙。首先确认ufw是否已经安装，执行下述命令，若返回ufw版本号，，则说明已经安装。\n1 ufw --version 没有安装的自己安装一下。\n执行下述命令设置ufw。\n1 2 3 4 5 6 7 8 9 10 11 #设置ufw默认值 sudo ufw default deny incoming sudo ufw default allow outgoing #允许SSH连接 sudo ufw allow ssh #允许http连接 sudo ufw allow http #允许https连接 sudo ufw allow https #开机启动 sudo ufw enable ufw其他常用命令：\n1 2 3 4 5 6 7 #查看ufw状态 sudo ufw status #ufw状态带行号输出，删除某一行 sudo ufw status numbered sudo ufw delete 5 #重载ufw配置 sudo ufw reload 更改SSH默认端口 打开nano或vim等编辑器打开文件/etc/ssh/sshd_config 1 vim /etc/ssh/sshd_config 在打开文件中找到Port这一项，去掉注释符#，并将22修改为新的端口号（1025-65535），本文以9753为例。 重启ssh服务，使变更生效。 1 service sshd restart 防火墙开放新端口号 1 ufw allow 9753/tcp comment \u0026#34;SSH\u0026#34; 防火墙中删除原来的22端口，下图删除了22/tcp，同样的方法把22/tcp(v6)也删除掉。 测试新端口号登陆\n注意：为了保证你不会失联，请不要关闭当前的ssh登录窗口！而是另外开一个窗口来测试！\n在新的终端窗口，用新的端口号登陆VPS。\n1 ssh root@100.200.300.400 -p 9753 设置仅密钥登陆 把公钥上传到VPS。 1 2 3 4 5 6 7 8 # 在家目录下新建.ssh文件夹 mkdir ~/.ssh # 修改.ssh文件夹权限 chmod 700 ~/.ssh # 上传公钥。将引号内的内容替换为公钥值 echo \u0026#34;Your public key content\u0026#34; \u0026gt;\u0026gt; ~/.ssh/authorized_keys # 修改authorized_keys文件权限 chmod 600 ~/.ssh/authorized_keys 禁止密码登录 1 vim /etc/ssh/sshd_config 找到PasswordAuthentication这一项，解注释并改为no，然后保存并退出。\n有些系统只改这一个没用，还要改下面这个。如果系统没有这个文件就忽略这一步。\n1 vim /etc/ssh/sshd_config.d/50-cloud-init.conf 同样，将PasswordAuthentication这一项，解注释并改为no，然后保存并退出。\n重启ssh服务，使变更生效。 1 service sshd restart 测试密钥登陆。 打开一个新的终端，用以下命令登陆VPS。\n1 ssh -i path/to/yourprivatekeyname -p 9753 root@100.200.300.400 将path/to/yourprivatekeyname修改为VPS使用的公钥的对应的私钥路径。通常在~/.ssh/下。\n新建普通用户 执行以下命令，新建一个用户。根据提示完成即可。 1 adduser leo 给新用户起个名字，本文以leo为例。\n将新用户leo加入sudo。 1 visudo 把公钥给新用户。 1 2 3 4 5 6 7 8 9 10 # 切换至新用户leo su leo # 在新用户leo家目录下创建.ssh文件夹 mkdir ~/.ssh # 修改.ssh文件夹权限 chmod 700 ~/.ssh # 上传公钥。将引号内的内容替换为公钥值 echo \u0026#34;公钥内容\u0026#34; \u0026gt;\u0026gt; ~/.ssh/authorized_keys # 修改authorized_keys文件权限 chmod 600 ~/.ssh/authorized_keys 这样新用户就可以用密钥登陆了。\n禁止root登录 打开/etc/ssh/sshd_config，找到PermitRootLogin这一项，解注释并将yes改为no。\n1 vim /etc/ssh/sshd_config 重启sshd服务，使变更生效。\n1 sudo service sshd restart 这样，root用户就无法登陆了，以后用leo用户管理VPS。\n安装Fail2Ban 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 安装Fail2Ban sudo apt update \u0026amp;\u0026amp; sudo apt install fail2ban # 建配置文件 sudo nano /etc/fail2ban/jail.local # 将以下内容粘贴在打开文件中 ******粘贴内容开始****** [sshd] enabled = true port = 9753 filter = sshd logpath = /var/log/auth.log maxretry = 5 bantime = 7200 findtime = 600 ******粘贴内容结束****** # 启动Fail2Ban sudo systemctl start fail2ban 上述配置的意思是：600秒内5次尝试登陆ssh的IP地址会被判7200秒有期徒刑。\nFail2Ban常用命令:\n1 2 3 4 5 6 7 8 9 10 11 12 # 重启Fail2Ban sudo systemctl restart fail2ban # 查看fail2ban服务状态 sudo systemctl status fail2ban # 将Fail2Ban设为开机启动 sudo systemctl enable fail2ban # 查看状态 sudo fail2ban-client status # 查看sshd jail的详细状态 sudo fail2ban-client status sshd # 解禁指定IP sudo fail2ban-client set sshd unbanip 192.0.0.1 至此，VPS安全配置已经完成。接下开是真正的搭梯子环节。\nXRay安装与配置 不推荐用任何一键脚本，谁知道里边有没有藏什么东西。官方文档足够详细，安装配置足够简单。此部分详细内容可查阅官方文档。\nInstall Xray GitHub仓库Xray-install是Xray官方提供的安装方式，在仓库README页可以找到官方安装脚本：\n1 bash -c \u0026#34;$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)\u0026#34; @ install 后期更新新版本也是这个命令。\n一键安装，足够简单吧。\nConfig Xray 生成一个合法的 UUID 并保存备用（UUID可以简单粗暴的理解为像指纹一样几乎不会重复的 ID）。\n1 xray uuid 这个uuid要留存，后边配置会用到。\n修改Xray配置文件。\n1 sudo nano /usr/local/etc/xray/config.json 将以下内容粘贴进去。只需修改port和id两项。本文port以12345为例，id以上一步生成的为例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 # 原始版本，VMess+Kcp，访问不了ChatGPT客户端 { \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34;, \u0026#34;access\u0026#34;: \u0026#34;/var/log/xray/access.log\u0026#34;, // 这是 Linux 的路径 \u0026#34;error\u0026#34;: \u0026#34;/var/log/xray/error.log\u0026#34; }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 12345, // 服务器监听端口 \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, // 主传入协议 \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;0061c282-49f7-41d7-b223-0a9b6d8675dd\u0026#34;, // uuid，客户端与服务器必须相同 \u0026#34;alterId\u0026#34;: 0 } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;kcp\u0026#34;, //此处的 kcp 也可写成 mkcp，两种写法是起同样的效果 \u0026#34;kcpSettings\u0026#34;: { \u0026#34;uplinkCapacity\u0026#34;: 15, \u0026#34;downlinkCapacity\u0026#34;: 100, \u0026#34;congestion\u0026#34;: true, \u0026#34;readBufferSize\u0026#34;: 1, \u0026#34;writeBufferSize\u0026#34;: 1, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;wireguard\u0026#34; } } } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, // 主传出协议 \u0026#34;settings\u0026#34;: {} } ] } 开放在配置文件中指定的端口号。\n1 2 sudo ufw allow 12345/tcp comment \u0026#34;XRay\u0026#34; sudo ufw allow 12345/udp comment \u0026#34;XRay\u0026#34; 启动Xray\n1 2 3 4 5 6 # 启动XRay sudo systemctl start xray # 将XRay设为开机启动 sudo systemctl enable xray # 查看XRay运行状态 sudo systemctl status xray 看到下图这样绿色的active(running)就说明XRay已成功启动，这样服务端就配置好了。\n开启BBR加速。\n给 Debian 10 添加官方 backports 源，获取更新的软件库。\n1 sudo nano /etc/apt/sources.list 然后把下面这一条加在最后，并保存退出。\n1 deb http://archive.debian.org/debian buster-backports main 刷新软件库并查询 Debian 官方的最新版内核并安装。请务必安装你的 VPS 对应的版本（本文以比较常见的【amd64】为例）。\n1 sudo apt update \u0026amp;\u0026amp; sudo apt -t buster-backports install linux-image-amd64 修改 kernel 参数配置文件 sysctl.conf 并指定开启 BBR\n1 sudo nano /etc/sysctl.conf 把下面的内容添加进去\n1 2 net.core.default_qdisc=fq net.ipv4.tcp_congestion_control=bbr 重启 VPS、使内核更新和BBR设置都生效。\n1 sudo reboot 确认BBR开启。\n1 lsmod | grep bbr 此时应该返回tcp_bbr这样的结果。\n如果你想确认 fq 算法是否正确开启，可以使用下面的命令：\n1 lsmod | grep fq 此时应该返回sch_fq这样的结果。\n配置客户端。\n服务端配置结束，接下来就是在你的客户端进行配置。根据客户端用的代理工具不同，配置方法也不太一样。但全都是根据服务端的配置进行。主要是把IP:Port和uuid配置为与服务端一致。\n客户端配置就不细讲了。\n这样，就已经可以科学上网了。只是无法使用ChatGPT客户端，因为ChatGPT对这些VPS厂商的IP进行了封锁。\nWarp解锁ChatGPT ChatGPT封锁了VPS厂商的IP地址，而Cloudflare的Warp可以提供供我们使用的IP地址，所以我们用Warp提供的IP地址去访问ChatGPT。但是，Warp提供的IPv4地址已经被滥用，也无法访问ChatGPT客户端了，所以我们用Warp IPv6。目标是访问寻常网站时用VPS的公网IPv4地址，访问ChatGPT时用Warp的IPv6地址。\n执行下面这个脚本安装WGCF。\n1 wget -N https://gitlab.com/fscarmen/warp/-/raw/main/menu.sh \u0026amp;\u0026amp; bash menu.sh 根据需要选择语言，本文选中文了。\n因为我们这台VPS是IPv4 only的机器，没有IPv6地址，我们仅需要Warp提供IPv6地址，所以选择2. 为IPv4 only添加Warp IPv6网络接口。\n工作模式选1.全局（默认）即可。\n选择账户类型。这里根据自己的需要选择，我自己有WARP的团队版，即Zero Trust，所以选择3. Teams。\n接下来就是登陆选择的账户。Teams账户选择2.通过组织名和邮箱验证码来登陆是比较方便的。\n优先级别选择3.使用VPS初始设置（默认）即可。\n这样WGCF会开始安装，等待安装完成，运行下面的命令，可以看到有一个叫warp的网卡。\n1 sudo ifconfig 这样VPS就有IPv6地址了。\n修改XRay的配置文件\n1 sudo nano /usr/local/etc/xray/config.json 用下面的内容覆盖。将IPv4地址替换为你的VPS公网IPv4地址，将IPv6地址替换为warp网卡的地址。uuid和port也要替换为自己的。其他的不用更改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 # Warp接管IPv6流量版本，VMess+Kcp，解锁ChatGPT客户端 { \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34;, \u0026#34;access\u0026#34;: \u0026#34;/var/log/xray/access.log\u0026#34;, // 这是 Linux 的路径 \u0026#34;error\u0026#34;: \u0026#34;/var/log/xray/error.log\u0026#34; }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 12345, // 服务器监听端口 \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, // 主传入协议 \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;0061c282-49f7-41d7-b223-0a9b6d8675dd\u0026#34;, // uuID，客户端与服务器必须相同 \u0026#34;alterId\u0026#34;: 0 } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;kcp\u0026#34;, //此处的 kcp 也可写成 mkcp，两种写法是起同样的效果 \u0026#34;kcpSettings\u0026#34;: { \u0026#34;uplinkCapacity\u0026#34;: 15, \u0026#34;downlinkCapacity\u0026#34;: 100, \u0026#34;congestion\u0026#34;: true, \u0026#34;readBufferSize\u0026#34;: 1, \u0026#34;writeBufferSize\u0026#34;: 1, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;wireguard\u0026#34; } } } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, // 主传出协议 \u0026#34;settings\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;UseIPv4\u0026#34; }, \u0026#34;sendThrough\u0026#34;: \u0026#34;100.200.300.400\u0026#34; //VPS公网IPv4地址 }, { \u0026#34;tag\u0026#34;: \u0026#34;warp\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;UseIPv6\u0026#34; }, \u0026#34;sendThrough\u0026#34;: \u0026#34;2606:4700:110:88b8:5141:4387:4a3:20d1\u0026#34; //warp网卡IPv6地址 } ], \u0026#34;routing\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:openai\u0026#34;, \u0026#34;geosite:bing\u0026#34;, \u0026#34;geosite:netflix\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;warp\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; } ] } } 重启XRay，并确认Xray已成功运行。\n1 2 sudo systemctl start xray sudo systemctl status xray 在客户端连接该节点，可以发现ChatGPT客户端已经可以正常使用。\nReferences Project X官方文档 保护好你的小鸡！保姆级服务器安全教程！ vps 解锁 chatgpt 注册Cloudflare并加入ZeroTrust教程 ","date":"2024-09-18T16:26:03+08:00","image":"https://xtls.github.io/LogoX2.png","permalink":"https://MasonCodingHere.github.io/p/build-your-own-ladder/","title":"私人代理——搭建专属于你的梯子"},{"content":"引言 继承是C++作为面向对象语言的一大特性。继承提高了代码的复用和可扩展性。子类可以把父类的数据成员“完整”地继承下来，而对于父类的成员函数，子类继承的是它们的调用权。 根据子类继承父类的个数，继承分为单继承、多继承：\n单继承，子类继承一个父类 多继承：子类继承多个父类 另外还有一种虚继承，虚继承其实是为了解决多继承带了的问题而引入的。后边再详述。 单继承没什么好说的，所以不单独列一节。并且下边的美人鱼例子，虽是为讲多继承而设计，但它也包含了单继承的内容。\n多继承 我们以美人鱼为例，美人鱼既有美人的某些属性，又有鱼的某些属性，可以把美人和鱼看作美人鱼的父类；而美人和鱼都是动物，可以把动物看作美人和鱼的共同父类。这样我们就可以定义如下几个类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Animal{ public: int data_Animal; }; class Beauty : public Animal{ public: int data_Beauty; }; class Fish : public Animal{ public: int data_Fish; }; class BeautyFish : public Beauty, public Fish{ public: int data_BeautyFish; }; 如果把这四个类的继承关系画成图，你就会发现，四个类组成一个菱形，这就是菱形继承。\n那么这四个类的对象会占用多大的内存呢？我在64位Linux平台下，用g++编译器的-fdump-class-hierarchy选项做了测试，为忽略内存对齐影响，使用#pragma pack(1)设为1字节对齐。测试结果如下：\n1 2 3 4 sizeof(Animal) == 4 sizeof(Beauty) == 8 sizeof(Fish) == 8 sizeof(BeautyFish) == 20 -fdump-class-hierarchy生成的文件内容如下（只保留以上四个类）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Class Animal size=4 align=1 base size=4 base align=1 Animal (0x0x7f11187c4d80) 0 Class Beauty size=8 align=1 base size=8 base align=1 Beauty (0x0x7f111860e5b0) 0 Animal (0x0x7f11187c4de0) 0 Class Fish size=8 align=1 base size=8 base align=1 Fish (0x0x7f111860e618) 0 Animal (0x0x7f11187c4e40) 0 Class BeautyFish size=20 align=1 base size=20 base align=1 BeautyFish (0x0x7f111861e540) 0 Beauty (0x0x7f111860e680) 0 Animal (0x0x7f11187c4ea0) 0 Fish (0x0x7f111860e6e8) 8 Animal (0x0x7f11187c4f00) 8 这是一个简单的模型，各个类都没有虚函数，所以不难想象为什么结果是这样。用图来表示，各个类的对象的内存布局大致如下：\n可以看到，在BeautyFish的对象内，保存了两份data_Animal，一份来自父类Beauty，另一份来自父类Fish。从功能上讲，BeautyFish的对象没有必要保存两份data_Animal，这样是非常浪费内存空间的，这就是多继承带来的数据冗余问题。\n除了数据冗余，多继承还会带来二义性问题。假设有下面这样的程序：\n1 2 3 4 5 6 int main(){ BeautyFish bf; bf.data_Animal = 2021; //语句1 bf.Beauty::data_Animal = 2021; //语句2 bf.Fish::data_Animal = 2021; //语句3 } 语句1将会产生二义性调用，bf内有两份data_Animal，程序不知道该去给哪一个进行赋值操作； 语句2和语句3可以正常通过，因为通过作用域限定符指明了具体给哪个data_Animal进行赋值操作。 虚继承 为了解决多继承带来的数据冗余与二义性问题，C++引入了虚继承机制。虚继承使子类只保留一份间接基类的成员，既节省内存空间，又避免了二义性的麻烦。\n于BeautyFish类而言，Beauty和Fish是它的直接基类，Animal则是它的间接基类。\n具体做起来也非常简单，只需要在Beauty和Fish继承Animal时，加一个virtual关键字。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Animal{ public: int data_Animal; }; class Beauty : public virtual Animal{ public: int data_Beauty; }; class Fish : public virtual Animal{ public: int data_Fish; }; class BeautyFish : public Beauty, public Fish{ public: int data_BeautyFish; }; 同样的方法，我们再来测一下四个类的对象的大小，测试结果如下：\n1 2 3 4 sizeof(Animal) == 4 sizeof(Beauty) == 16 sizeof(Fish) == 16 sizeof(BeautyFish) == 32 -fdump-class-hierarchy生成的文件内容如下（只保留以上四个类）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 Class Animal size=4 align=1 base size=4 base align=1 Animal (0x0x7f758e638d80) 0 Vtable for Beauty Beauty::_ZTV6Beauty: 3u entries 0 12u 8 (int (*)(...))0 16 (int (*)(...))(\u0026amp; _ZTI6Beauty) VTT for Beauty Beauty::_ZTT6Beauty: 1u entries 0 ((\u0026amp; Beauty::_ZTV6Beauty) + 24u) Class Beauty size=16 align=1 base size=12 base align=1 Beauty (0x0x7f758e4825b0) 0 vptridx=0u vptr=((\u0026amp; Beauty::_ZTV6Beauty) + 24u) Animal (0x0x7f758e638de0) 12 virtual vbaseoffset=-24 Vtable for Fish Fish::_ZTV4Fish: 3u entries 0 12u 8 (int (*)(...))0 16 (int (*)(...))(\u0026amp; _ZTI4Fish) VTT for Fish Fish::_ZTT4Fish: 1u entries 0 ((\u0026amp; Fish::_ZTV4Fish) + 24u) Class Fish size=16 align=1 base size=12 base align=1 Fish (0x0x7f758e482618) 0 vptridx=0u vptr=((\u0026amp; Fish::_ZTV4Fish) + 24u) Animal (0x0x7f758e638e40) 12 virtual vbaseoffset=-24 Vtable for BeautyFish BeautyFish::_ZTV10BeautyFish: 6u entries 0 28u 8 (int (*)(...))0 16 (int (*)(...))(\u0026amp; _ZTI10BeautyFish) 24 16u 32 (int (*)(...))-12 40 (int (*)(...))(\u0026amp; _ZTI10BeautyFish) Construction vtable for Beauty (0x0x7f758e482680 instance) in BeautyFish BeautyFish::_ZTC10BeautyFish0_6Beauty: 3u entries 0 28u 8 (int (*)(...))0 16 (int (*)(...))(\u0026amp; _ZTI6Beauty) Construction vtable for Fish (0x0x7f758e4826e8 instance) in BeautyFish BeautyFish::_ZTC10BeautyFish12_4Fish: 3u entries 0 16u 8 (int (*)(...))0 16 (int (*)(...))(\u0026amp; _ZTI4Fish) VTT for BeautyFish BeautyFish::_ZTT10BeautyFish: 4u entries 0 ((\u0026amp; BeautyFish::_ZTV10BeautyFish) + 24u) 8 ((\u0026amp; BeautyFish::_ZTC10BeautyFish0_6Beauty) + 24u) 16 ((\u0026amp; BeautyFish::_ZTC10BeautyFish12_4Fish) + 24u) 24 ((\u0026amp; BeautyFish::_ZTV10BeautyFish) + 48u) Class BeautyFish size=32 align=1 base size=28 base align=1 BeautyFish (0x0x7f758e492540) 0 vptridx=0u vptr=((\u0026amp; BeautyFish::_ZTV10BeautyFish) + 24u) Beauty (0x0x7f758e482680) 0 primary-for BeautyFish (0x0x7f758e492540) subvttidx=8u Animal (0x0x7f758e638ea0) 28 virtual vbaseoffset=-24 Fish (0x0x7f758e4826e8) 12 subvttidx=16u vptridx=24u vptr=((\u0026amp; BeautyFish::_ZTV10BeautyFish) + 48u) Animal (0x0x7f758e638ea0) alternative-path 虽然只是加了个virtual，但我们可以看到上边的文件已经比之前的复杂很多了。经过分析上边的文件，结合gdb的打印类布局的内容以及网上相关博客，我还是分析出了四个类的内存布局。\nAnimal、Beauty和Fish的内存模型如下图：\nAnimal类对象的内存布局与之前一模一样，不再赘述。\nBeauty和Fish内存模型是一样的，我们以Beauty为例讲解。\n虚继承的话，子类的对象里首先存的是自己的东西，最后才是虚基类的东西； 非虚继承的话，子类的对象里首先存的是基类的东西，最后才是自己的东西。如果有多个基类，则按照继承的顺序，第一个基类被设为主基类。 由于是Beauty虚继承Animal，所以在Beauty对象的内存里，首先是虚指针vptr和Beauty自己的数据data_Beauty，最后才是从虚基类Animal继承来的data_Animal。\nBeauty的虚表有三个内容：\n第一个slot是vbase_offset，其值是12。这个值的意思是，Beauty中虚基类的部分（即Animal的部分）在Beauty对象内存中的偏移量是12。我们可以看到从Beauty对象的内存首地址偏移12个字节正好是data_Animal的地址。 第二个slot是offset_to_top。将对象从当前这个类型（this指针）转换为该对象的实际类型的地址偏移量； 第三个slot是type_info_for_Beauty,用于RTTI。 第二和第三个slot里的内容还没有弄明白，这里就先不多说了。\nBeautyFish就比较复杂了，其内存布局大致如下：\nBeautyFish非虚继承Beauty和Fish，所以BeautyFish对象的内存里，首先是基类的东西，即Beauty的虚指针和数据、Fish的虚指针和数据，然后是BeautyFish自己的数据，最后是虚基类Animal的数据。\nBeautyFish的虚表这里不再展开。\n总结 关于C++对象的内存布局，C++标准并没有作出严格的约束，只是做了一个框架性的约束，而具体的实现交由编译器自己来完成。所以就导致C++对象模型相关内容是编译器相关的，不同的编译器可能会有不同的结果。\n以我所知道的，GCC和VC++对于C++对象内存模型的实现差别就很大。比如对于虚基类，GCC的做法是扩展了虚表（virtual table）；而VC++则是模仿虚表，建了一个虚基类表（virtual base class table），正如虚指针vptr指向虚表一样，VC++会在C++对象里加一个虚基类指针vbptr，该指针指向虚基类表。\n这些东西有些繁杂，我也不能保证写的一定正确，很多东西都是自己分析得出，只为建立自己的C++对象模型观。如有朋友发现有误，欢迎指出。\n","date":"2021-06-22T06:19:43-07:00","permalink":"https://MasonCodingHere.github.io/p/cpp-multiple-inheritance/","title":"美人+鱼=美人鱼——谈C++多继承"}]