<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Protocol on Mason&#39;s Blog</title>
        <link>https://MasonCodingHere.github.io/tags/protocol/</link>
        <description>Recent content in Protocol on Mason&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>Mason</copyright>
        <lastBuildDate>Mon, 17 May 2021 00:14:35 -0700</lastBuildDate><atom:link href="https://MasonCodingHere.github.io/tags/protocol/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Tcp Introduction Deeper</title>
        <link>https://MasonCodingHere.github.io/p/tcp-introduction-deeper/</link>
        <pubDate>Mon, 17 May 2021 00:14:35 -0700</pubDate>
        
        <guid>https://MasonCodingHere.github.io/p/tcp-introduction-deeper/</guid>
        <description>&lt;h1 id=&#34;引言&#34;&gt;引言
&lt;/h1&gt;&lt;p&gt;在《TCP的三次握手与四次挥手》中，我们已经了解了一个TCP连接的建立与终止的规则及这个过程中发送的各个类型的报文段。这些决定TCP应该做什么的规则其实是由当前TCP连接所属的状态决定的。当前的状态会在各种触发条件下发生改变。常见的触发条件如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传输或接收到某报文段；&lt;/li&gt;
&lt;li&gt;计时器超时；&lt;/li&gt;
&lt;li&gt;客户端/服务端应用程序的读写操作；&lt;/li&gt;
&lt;li&gt;来自其他层的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些规则可以概括为TCP的状态转换图。&lt;/p&gt;
&lt;p&gt;本文就以TCP状态转换为出发点，再探TCP的连接管理相关内容。&lt;/p&gt;
&lt;h1 id=&#34;tcp状态转换图&#34;&gt;TCP状态转换图
&lt;/h1&gt;&lt;p&gt;TCP定义了11种状态，状态名字基于netstat命令所输出的名称。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CLOSED状态作为开始状态点和终止状态点，但它并不能算一个“官方”状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/MasonCodingHere/PicsBed_1/main/tcp-introduction-deeper/TCP-satus-machine.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;典型tcp过程&#34;&gt;典型TCP过程
&lt;/h1&gt;&lt;p&gt;所谓&lt;strong&gt;典型TCP过程&lt;/strong&gt;，这个词是我定的，即上图中黑线表示的过程的有序集合。这些黑线组成的典型TCP过程不考虑同时打开与关闭、重置等特殊情况。本节描述这个过程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以看到除了CLOSING，其他10种状态均在典型TCP过程中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;开始时，客户端/服务端均处于CLOSED状态；&lt;/li&gt;
&lt;li&gt;服务端进程启动，调用listen函数后，服务端由CLOSED转换为LISTEN；&lt;/li&gt;
&lt;li&gt;客户端进程启动，调用connect函数后，TCP三路握手建立连接过程被激起，客户端发送第一路握手请求的SYN报文段，然后由CLOSED转换为SYN_SENT；&lt;/li&gt;
&lt;li&gt;服务端接收到客户端发来的SYN报文段，发起第二路握手请求，向客户端发送SYNACK报文段，然后由LISTEN转换为SYN_RCVD；&lt;/li&gt;
&lt;li&gt;客户端接收到服务端发来的SYNACK报文段，发起第三路握手请求，向服务端发送ACK报文段，然后由SYN_SENT转换为ESTABLISHED，至此，客户端已完成连接；&lt;/li&gt;
&lt;li&gt;服务端收到客户端发来的ACK报文段，也由SYN_RCVD转换为ESTABLISHED，至此双方连接建立完成；&lt;/li&gt;
&lt;li&gt;ESTABLISHED是通信双方双向传输数据的状态；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;尽管双方均可发起主动关闭操作，但我们以客户端负责执行主动关闭为例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;数据传输结束，客户端调用close函数关闭套接字描述符，激起TCP四路握手关闭连接的过程，客户端发送第一路握手的FIN报文段，然后由ESTABLISHED转换为FIN_WAIT_1；&lt;/li&gt;
&lt;li&gt;服务端收到客户端发来的FIN报文段，发起第二路握手，向客户端发送ACK报文段，然后由ESTABLISHED转换为CLOSE_WAIT；&lt;/li&gt;
&lt;li&gt;客户端收到服务端发来的ACK报文段，&lt;strong&gt;什么都不发送&lt;/strong&gt;，由FIN_WAIT_1转换为FIN_WAIT_2；&lt;/li&gt;
&lt;li&gt;服务端调用close函数，发起第三路握手，向客户端发送FIN报文段，由CLOSE_WAIT转换为LAST_ACK；&lt;/li&gt;
&lt;li&gt;客户端收到服务端发来的FIN报文段，发起第四路握手，向服务端发送ACK报文段，由FIN_WAIT_2转换为TIME_WAIT；&lt;/li&gt;
&lt;li&gt;服务端收到客户端发来的ACK报文段，什么都不发送，由LAST_ACK转换为CLOSED，至此服务端关闭；&lt;/li&gt;
&lt;li&gt;客户端等待2MSL，计时器超时后，客户端由TIME_WAIT转换为CLOSED，至此双方连接彻底关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;非典型tcp过程&#34;&gt;非典型TCP过程
&lt;/h1&gt;&lt;p&gt;TCP状态转换图中还有一些非典型过程，在图中用蓝色表示。下边我们描述一下这些部分。这些非典型过程包括以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连接建立超时&lt;/li&gt;
&lt;li&gt;同时打开&lt;/li&gt;
&lt;li&gt;同时关闭&lt;/li&gt;
&lt;li&gt;重置报文段（RST）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;连接建立超时&#34;&gt;连接建立超时
&lt;/h2&gt;&lt;p&gt;有时会存在连接不能建立的情况，比如服务器关闭的情况。&lt;/p&gt;
&lt;p&gt;当客户端发送SYN报文段，但迟迟得不到回应的时候，客户端就会频繁地发送SYN报文段，直到达到限定的次数，客户端放弃与服务端进行连接，&lt;strong&gt;由SYN_SENT转换为CLOSED&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux系统默认重试次数为5次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;指数回退&lt;/strong&gt;：首个SYN报文段发送后3秒发送第二个SYN报文段，第二个报文段发送后6秒后发送第三个SYN报文段，第三个报文段发送后12秒后发送第四个SYN报文段，以此类推，即每一次回退数值都是前一次的两倍。&lt;/p&gt;
&lt;h2 id=&#34;同时打开过程&#34;&gt;同时打开过程
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/MasonCodingHere/PicsBed_1/main/tcp-introduction-deeper/opening-same-time.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;TCP支持双方同时打开的情况，要实现同时打开，有两个要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通信双方均有彼此的套接字地址结构sockaddr_in；（正常情况下，只有客户端知道服务端的套接字地址，而服务端不知道客户端的。）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通信双方在收到来自对方的SYN报文段&lt;strong&gt;之前&lt;/strong&gt;必须先发送一个SYN报文段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;由于双方均同时扮演了客户端与服务端的角色，所以不能将任何一方称为客户端或服务端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如上图所示，同时打开的过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双方在CLOSED状态时，通过调用connect函数，均在接收到对方的SYN报文段之前，自己就先发送了一个SYN报文段，双方均进入SYN_SENT状态；&lt;/li&gt;
&lt;li&gt;在接收到对方发来的SYN报文段后，双方均向彼此发送SYNACK报文段，并进入SYN_RCVD状态；&lt;/li&gt;
&lt;li&gt;双方在接收到彼此的SYNACK报文段后，均进入ESTABLISHED状态，连接建立完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;可以看到，同时打开过程需要交换四个报文段，比普通的三路握手增加了一个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;同时关闭过程&#34;&gt;同时关闭过程
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/MasonCodingHere/PicsBed_1/main/tcp-introduction-deeper/closing-same-time.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在接收到对方发来的FIN报文段之前，双方均向对方发送FIN报文段，这会触发同时关闭过程。&lt;/p&gt;
&lt;p&gt;如上图，同时关闭过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双方在ESTABLISHED状态时，通过调用close函数，均在收到对方的FIN报文段之前，向对方发送了FIN报文段，双方均进入FIN_WAIT_1状态；&lt;/li&gt;
&lt;li&gt;双方并没有如预期收到对方的ACK报文段，而是收到了FIN报文段，双方均向对方回应ACK报文段，均进入CLOSING状态；&lt;/li&gt;
&lt;li&gt;双方收到对方发来的ACK报文段后，均进入TIME_WAIT状态，待2MSL超时后，进入CLOSED状态，至此连接彻底关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;FIN报文段还包含一个ACK段用于确认对方最近一次发来的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到同时关闭过程与正常关闭过程交换相同数量的报文段，二者的区别在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正常关闭过程中报文段序列是不交叉的，一个发，另一个收到之后再发；&lt;/li&gt;
&lt;li&gt;同时关闭过程中报文段序列是交叉的，一个发的同时另一个也再发。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;同时关闭过程用到了一个正常过程中没有的状态：CLOSING。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;重置报文段rst&#34;&gt;重置报文段（RST）
&lt;/h2&gt;&lt;p&gt;一个将TCP头部中的RST字段置1的报文段称为&lt;strong&gt;重置报文段&lt;/strong&gt;，它用于关闭那些已经没有必要继续存在的连接。&lt;/p&gt;
&lt;p&gt;以下是常见的产生重置报文段的场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客户端发起一个连接请求，服务端却没有相应的进程在目的端口监听时，服务端就会给该客户端发送一个重置报文段；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;终止一条连接。在任何时刻均可以发送一个重置报文段替代FIN来终止一条连接，通过这种方式终止连接时，任何排队的数据都将被抛弃，重置报文段立即发送出去；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在不告知另一方的情况下，通信的一端关闭或终止了连接，将导致这条TCP连接处于&lt;strong&gt;半开&lt;/strong&gt;状态。这通常发生在通信一方的主机崩溃的情况下。这种情况下只要不尝试通过这条半开连接传输数据，正常工作的一端将不会检测到另一端已经崩溃（因为崩溃的一端连重置报文段或者FIN报文段都没办法发出去）。这时如果崩溃的一端重新连接，它对这条连接上另一端发送过来的数据一无所知，TCP规定此时崩溃一方将回复一个重置报文段以关闭这个连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP的TIME_WAIT状态的目的是让任何一个受制于与数据相关的关闭连接的数据被丢弃。在这段时期，等待的一方通常不需要任何操作，它只需要维持当前状态直到2MSL的计时结束。然而，如果它在这段时期内接收到来自于这条连接的一个重置报文段时，它的TIME_WAIT状态就会被破坏而提前进入CLOSED状态。&lt;/p&gt;
&lt;p&gt;为什么连接的被动关闭方会发送重置报文段呢？在连接的主动关闭方进入TIME_WAIT状态前，它回复一个ACK以告知被动关闭方自己已经接收到FIN报文段，被动关闭方收到这个ACK后随即进入CLOSED状态，此时主动关闭方还在TIME_WAIT状态等待2MSL计时结束。在这个时期，网络中可能存在延时，被动关闭方之前发送的对某数据的ACK在这个时候才姗姗来迟，此时这个ACK对处于TIME_WAIT状态的主动关闭方来说是旧的消息，因此它会发送一个ACK作为响应，其中包含了最新的序列号与ACK值。已经处于CLOSED状态的被动关闭方收到这个ACK后就会发送一个&lt;strong&gt;重置报文段&lt;/strong&gt;作为响应。这会导致另一端的TIME_WAIT状态过早结束而进入CLOSED状态。解决这个错误的最简单方法就是让处于TIME_WAIT状态的TCP连接不对重置报文段做出响应。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;tcp其他问题&#34;&gt;TCP其他问题
&lt;/h1&gt;&lt;h2 id=&#34;time_wait状态&#34;&gt;TIME_WAIT状态
&lt;/h2&gt;&lt;p&gt;在TIME_WAIT状态中，TCP将会等待两倍于&lt;strong&gt;最大段生存期&lt;/strong&gt;（MSL）的时间，MSL代表任何报文段在被丢弃前在网络中被允许存在的最长时间。&lt;/p&gt;
&lt;p&gt;TIME_WAIT状态有两个存在的理由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可靠地实现TCP全双工连接的终止；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;第一个理由可以通过断开连接时客户端最终发送给服务端的，以响应服务端的FIN报文段的ACK报文段丢失来解释。服务端迟迟收不到ACK，服务端就重发它的FIN报文段，如果没有TIME_WAIT状态，客户端就直接处于CLOSED状态了，那客户端就没有该连接的信息了，客户端就会回复给服务端一个重置报文段，这就不是正常断开连接的过程了；所以客户端需要有一个TIME_WAIT状态，来维护这个连接，从而可以发送ACK来响应服务端重传过来的FIN报文段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;允许老的重复分组在网络中消逝。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;第二个理由解释：如果一条TCP连接关闭之后，双方再以相同的四元组建立新连接，如果旧连接中有一些分组还在网络中，由于IP地址和端口号相同，这些分组就可能到达新连接，这样就会产生混乱。为了避免这个情况，设置TIME_WAIT状态，等待2MSL时间，在这段时间内，旧连接的四元组仍被占用，无法用相同的四元组建立新连接，这样就避免了新旧连接的数据混乱；同时，2MSL的时间足够让旧连接的分组在网络中消逝，这样再用相同的四元组建立连接时，就可以保证新连接不会接受到旧连接的分组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;listen函数的第二个参数&#34;&gt;listen函数的第二个参数
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;listen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;backlog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//成功返回0，出错返回-1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;backlog参数规定了内核应为sockfd排队的最大连接个数，为了理解backlog参数，我们必须认识到内核为每一个监听套接字维护两个队列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未完成连接队列：那些处于SYN_RCVD状态的套接字组成的队列。即客户端发来的SYN报文段已到达服务端，服务端正在等待完成三路握手过程；&lt;/li&gt;
&lt;li&gt;已完成连接队列：那些处于ESTABLISHED状态的套接字组成的队列，即每个已完成三路握手过程的客户端对应该队列中的一项。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;上述两队列之和不能超过backlog。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;tcp半关闭&#34;&gt;TCP半关闭
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/MasonCodingHere/PicsBed_1/main/tcp-introduction-deeper/half-closing.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;TCP支持半关闭操作。&lt;/p&gt;
&lt;p&gt;伯克利套接字的API提供了半关闭操作，应用程序只需要调用shutdown函数来代替基本的close函数，就能实现上述操作。&lt;/p&gt;
&lt;h2 id=&#34;初始序列号的选取&#34;&gt;初始序列号的选取
&lt;/h2&gt;&lt;p&gt;由于客户端和服务端之间的TCP连接是由客户端的IP地址及端口号和服务端的IP地址及端口号构成的四元组所确定的，因此当客户端出现了故障把这个TCP连接断开了，之后再以相同的四元组建立新的TCP连接（也就是说客户端和服务端两次建立TCP连接都是使用了相同的IP地址和端口号），就会出现数据乱序的问题。&lt;/p&gt;
&lt;p&gt;换句话说，只要客户端发送了一个TCP报文段，且这个TCP报文段的四元组和序列号，和之前的TCP连接（四元组和序列号）相同的话，就会被服务端确认。这其实反映了TCP的脆弱性，如果TCP的这种缺点被一些恶意攻击者加以利用：选择合适的序列号、IP地址和端口号的话，就能伪造出一个TCP报文段，从而打断正常的TCP连接。那么通过谨慎选取初始化序列号的方式（通过算法来随机生成序列号）就会使序列号难以猜出，也就不容易利用这种缺点来进行一些恶意攻击行为。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux系统采用基于时钟的方案来选取初始化序列号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;tcp-mtu的发现&#34;&gt;TCP MTU的发现
&lt;/h2&gt;&lt;p&gt;MTU，即最大路径传输单元，指经过两台主机之间路径的所有网络报文段中最大传输单元的最小值。&lt;/p&gt;
&lt;p&gt;当中间路由器的最大传输单元小于任何一个通信端的最大段大小（MSS）时，TCP就会执行路径最大传输单元发现过程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IPv4头部中有一个3位的&lt;strong&gt;标志&lt;/strong&gt;字段，目前只有低两位有意义，其中中间一位叫做&lt;strong&gt;DF&lt;/strong&gt;位（Don&amp;rsquo;t Fragment），当该位置1时代表不能分片。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;TCP发送端发送数据时将IP数据报中的DF位置1，这样中间路由器如果收到分片才能处理的过大的数据报时，中间路由器不会分片，而是将该数据报丢弃；&lt;/li&gt;
&lt;li&gt;路由器通过ICMP把链路上的MTU值通知TCP发送端；&lt;/li&gt;
&lt;li&gt;TCP发送端获得ICMP所通知的MTU值以后，将它设置为当前的MTU。TCP发送端发送根据这个MTU对数据报进行分片处理。如此反复，直到数据报被发送到目标主机为止没有再收到任何ICMP，就认为最后一次ICMP所通知的MTU即是一个合适的MTU值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tcp选项&#34;&gt;TCP选项
&lt;/h2&gt;&lt;p&gt;TCP头部中包含了多个选项，常见的选项如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EOL：指出了选项列表的结尾，表示选项列表结束，说明无需对选项列表再进行处理。&lt;/li&gt;
&lt;li&gt;NOP：允许发送者在必要的时候用多个4字节组&lt;strong&gt;填充&lt;/strong&gt;某个字段。&lt;/li&gt;
&lt;li&gt;MSS：最大段大小，即TCP协议所允许的从对方接收到的最大报文段。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;一方把MSS发送给对方时，不是在商量，而是在通知对方，它表示在整个连接过程中都不愿意接收比MSS值大的报文段。&lt;/p&gt;
&lt;p&gt;MSS的值是TCP数据载荷部分的字节数，而不包括TCP与IP头部。&lt;/p&gt;
&lt;p&gt;建立一条TCP连接时，通信双方应该在SYN报文段的MSS选项中向对方说明自己允许的最大段大小。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MSS的默认值是536字节，加上TCP头部20字节和IPv4头部20字节，一共组成576字节的IPv4数据报，这是标准中规定的任何主机都应该能处理的IPv4数据报的最小大小；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPv4中常见的MSS值为1460字节，加上TCP头部20字节和IPv4头部20字节，共组成1500字节的IPv4数据报，这正好是链路层中以太网的最大传输单元（MTU）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于IPv6头部比IPv4头部大20字节，所以MSS值相应减20字节，为1440字节。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;SACK：选择确认选项。接收方通过这个选项来描述乱序的数据（空洞），帮助发送方重传；&lt;/li&gt;
&lt;li&gt;窗口缩放选项：用于将TCP&lt;strong&gt;窗口大小&lt;/strong&gt;字段的范围从16位增加至30位。该选项作为16位窗口大小的比例因子，最大比例数值为14，可将窗口大小的最大值由65535字节扩展至1GB；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;窗口缩放选项只能出现在SYN报文段中，连接建立后比例因子与方向绑定，每个方向的比例因子可以各不相同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;时间戳选项：发送方根据该选项通过每一个接收到的ACK来估算TCP连接的往返时间，并根据结果设置重传超时；&lt;/li&gt;
&lt;li&gt;用户超时选项：指明了TCP发送者在确认对方未能成功接收数据之前愿意等待该数据ACK确认的时间；&lt;/li&gt;
&lt;li&gt;认证选项：用于增强连接的安全性。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>TCP:传输控制协议</title>
        <link>https://MasonCodingHere.github.io/p/tcp-introduction/</link>
        <pubDate>Mon, 10 May 2021 00:07:46 -0700</pubDate>
        
        <guid>https://MasonCodingHere.github.io/p/tcp-introduction/</guid>
        <description>&lt;h1 id=&#34;引言&#34;&gt;引言
&lt;/h1&gt;&lt;p&gt;所谓可靠传输，有以下四点要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不损坏，即接收到的数据不存在比特差错；&lt;/li&gt;
&lt;li&gt;不丢失，即接收到的数据无间隙；&lt;/li&gt;
&lt;li&gt;不重复，即接收到的数据不重复；&lt;/li&gt;
&lt;li&gt;不乱序，即接收到的数据是按次序的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通信介质由于一些原因可能会造成比特差错和分组丢失。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用差错校正码，即添加一些冗余比特用于恢复比特差错；&lt;/li&gt;
&lt;li&gt;重传机制：即重新传送信息，直到它被正确接收为止。重传可以解决比特差错和分组丢失。TCP就采用重传机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;重传机制&#34;&gt;重传机制
&lt;/h1&gt;&lt;p&gt;通过重传机制解决比特差错和分组丢失，需要判断两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是不是发生了分组丢失，即接收方是否已收到分组？&lt;/li&gt;
&lt;li&gt;是不是发生了比特差错，即接收方收到的分组是否与之前发送方发送的一样？&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;对于检测是否发生了比特差错，可以通过&lt;strong&gt;校验和&lt;/strong&gt;来完成；但是校验和只能检测，并不能实现差错纠正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;ack机制&#34;&gt;ACK机制
&lt;/h1&gt;&lt;p&gt;为了判断重传机制带来的第一个问题（即是否发生分组丢失），引入了&lt;strong&gt;ACK机制&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;接收方收到分组后，给发送方发送一个ACK，以确认自己收到了分组；发送方收到ACK后，再发送下一个分组，继续等待新分组的ACK，这个过程就这样进行下去。&lt;/p&gt;
&lt;p&gt;但ACK机制也带来了一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送方等待ACK应该等多长时间？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个问题比较复杂，暂时不讨论，到《TCP的超时与重传》再讨论。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果ACK丢失了怎么办？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个问题比较容易，超过了发送方等待ACK的时间，发送方就再把原分组发送一遍就可以了。当然这可能带来分组重复问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果分组接收到了，但是通过校验和检测到分组存在比特差错怎么办？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个也比较简单，接收方收到存在比特差错的分组后，将不发送ACK，时间一到，发送方重发完整到达的无差错的分组。&lt;/p&gt;
&lt;h1 id=&#34;序列号机制&#34;&gt;序列号机制
&lt;/h1&gt;&lt;p&gt;从上边可以看出，对于ACK丢失的情况，发送方简单地重发原分组，这将导致接收方接收到重复的分组。&lt;/p&gt;
&lt;p&gt;为了解决分组重复问题，引入&lt;strong&gt;序列号机制&lt;/strong&gt;来解决&lt;/p&gt;
&lt;p&gt;发送方发送分组时，每个分组都有一个唯一的序列号，这个序列号由分组自身一直携带着。接收方可以使用这个序列号来判断它是否已经收到过这个分组，如果是则丢弃它，保留之前的就好了。&lt;/p&gt;
&lt;h1 id=&#34;滑动窗口机制&#34;&gt;滑动窗口机制
&lt;/h1&gt;&lt;p&gt;到目前为止，以上的协议是可靠的，但是效率比较低，因为它是一个停等协议，即发送方注入一个分组到通信路径，然后停下来等待，直到接收到来自接收方给这个分组反馈的ACK，发送方才能发送下一个分组。&lt;/p&gt;
&lt;p&gt;为了提高吞吐量，我们可以允许发送方同时发送多个分组，这将带来更多需要考虑的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送方每次应该发多少个分组？&lt;/li&gt;
&lt;li&gt;发送方应该保存哪些分组的副本已备重传？&lt;/li&gt;
&lt;li&gt;接收方的ACK机制如何区分哪些分组收到了，哪些分组还没收到？&lt;/li&gt;
&lt;li&gt;接收方收到分组的顺序与发送方的发送顺序不同，即乱序问题如何解决？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决这些问题，引入了&lt;strong&gt;滑动窗口机制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/MasonCodingHere/PicsBed_1/main/tcp-introduction/slide-window-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上图显示了一个发送方窗口，3号分组已被发送并确认，所以由发送方保存的它的副本可以被释放；7号分组在发送方已准备好，但还未被发送，因为它还没有进入窗口。&lt;/p&gt;
&lt;p&gt;现在我们可以想象，发送方下一步就接收到分组4的ACK，所以整个窗口向右滑动一个分组，变成下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/MasonCodingHere/PicsBed_1/main/tcp-introduction/slide-window-2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这意味着4号分组现在可以释放了，而7号分组可以被发送了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般，发送方和接收方都有自己的滑动窗口结构。&lt;/p&gt;
&lt;p&gt;发送方的窗口记录着哪些分组可以被释放，哪些分组正在等待ACK，哪些分组还不能被发送；&lt;/p&gt;
&lt;p&gt;接收方的窗口记录着哪些分组已接收和确认，哪些分组是下一步期望接收的，以及哪些分组即使被接收也会因内存限制而被丢弃。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;滑动窗口机制又带来一些需要考虑的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;窗口大小应该是多少？&lt;/li&gt;
&lt;li&gt;如果接收方或网络处理不过来发送方的数据率时该怎么办？&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;流量控制和拥塞控制&#34;&gt;流量控制和拥塞控制
&lt;/h1&gt;&lt;p&gt;为了解决滑动窗口机制带来的问题，引入了流量控制和拥塞控制。&lt;/p&gt;
&lt;h2 id=&#34;流量控制&#34;&gt;流量控制
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;流量控制&lt;/strong&gt;：当接收方相对于发送方太慢时，强迫发送方慢一点。&lt;/p&gt;
&lt;p&gt;流量控制的主要形式为基于滑动窗口进行流量控制，在这种方法里：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滑动窗口大小不固定，允许随时间而变动；&lt;/li&gt;
&lt;li&gt;接收方通过&lt;strong&gt;窗口通告&lt;/strong&gt;通知发送方更新自己的窗口大小；&lt;/li&gt;
&lt;li&gt;窗口通告通常与ACK一起由同一个分组携带，即发送方在向右滑动窗口的同时调整窗口的大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;拥塞控制&#34;&gt;拥塞控制
&lt;/h2&gt;&lt;p&gt;流量控制解决了接收方相对于发送方慢的问题，但是一般在发送方和接收方之间还有很多路由器，它们的内存有限，如果发送方发送的太快，快到超过了这之间某台路由器的承受能力，就会导致丢包。&lt;/p&gt;
&lt;p&gt;这个问题通过&lt;strong&gt;拥塞控制&lt;/strong&gt;机制来解决。&lt;/p&gt;
&lt;h1 id=&#34;超时重传机制&#34;&gt;超时重传机制
&lt;/h1&gt;&lt;p&gt;为解决“发送方等待ACK应该等多长时间才能判定分组丢失并重发它”这个问题，引入了&lt;strong&gt;超时重传机制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;直观上，发送方重新发送一个分组之前应等待以下时间的总和：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送分组所用的时间；&lt;/li&gt;
&lt;li&gt;接收方处理分组的时间；&lt;/li&gt;
&lt;li&gt;接收方发送一个ACK所用的时间；&lt;/li&gt;
&lt;li&gt;ACK到达发送方所用的时间；&lt;/li&gt;
&lt;li&gt;发送方处理ACK所用的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不幸的是，谁都不知道这些时间是多少，而且它们会随网络环境和主机负载而变化。&lt;/p&gt;
&lt;p&gt;所以采用的策略是：让协议实现尝试去估计这些时间，称为往返时间估计（RTT）。&lt;/p&gt;
&lt;h1 id=&#34;tcp中的可靠性&#34;&gt;TCP中的可靠性
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;TCP服务模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP提供了一种面向连接的可靠的字节流服务。&lt;/p&gt;
&lt;p&gt;面向连接的，即通信双方需要建立一条端到端连接；&lt;/p&gt;
&lt;p&gt;字节流：应用层传下来的数据会被TCP打散成TCP认为的最佳大小的块来发送，一般使得每个报文段按照不会被分片的单个IP层数据报的大小来划分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TCP通过前述各种技术机制的变种，实现了可靠数据传输。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序列号&lt;/strong&gt;：在TCP中序列号实际代表了每个分组的第一个字节在整个字节流中的字节偏移，而非分组号；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;校验和&lt;/strong&gt;：在TCP中用于检测传送中的比特差错；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重传计时器&lt;/strong&gt;：当TCP发送一组报文段时，它通常设置一个重传计时器，等待对方的ACK。TCP不会为每个报文段各自设置一个重传计时器，而是发送一个窗口的数据只设置一个重传计时器，当ACK到达时更新超时；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACK机制&lt;/strong&gt;：TCP的ACK是累积的，即指示字节号N的ACK到达意味着N（不含N）之前的所有字节都成功收到了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;窗口通告：&lt;strong&gt;因为TCP提供的是&lt;/strong&gt;双工&lt;/strong&gt;服务，A给B发数据时的TCP报文段同时也包含了对B发给A的数据的ACK，同时每个报文段也包含一个&lt;strong&gt;窗口通告&lt;/strong&gt;实现相反方向上的流量控制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乱序问题&lt;/strong&gt;：TCP绝不会以杂乱次序给上层应用程序发数据。因此，TCP接收端可能会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号报文段一一到达，空洞被填满再往应用程序交付数据。&lt;/p&gt;
&lt;h1 id=&#34;tcp头部结构&#34;&gt;TCP头部结构
&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/MasonCodingHere/PicsBed_1/main/tcp-introduction/TCP-header.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源/目的端口：与IP头部中的源/目的IP地址一起，唯一地标识了每个连接；&lt;/li&gt;
&lt;li&gt;序列号：标识了TCP发送端到接收端的数据流的一个字节，该字节代表着包含该序列号的报文段的数据中的第一个字节；&lt;/li&gt;
&lt;li&gt;确认号：其值是该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节的序列号加1；&lt;/li&gt;
&lt;li&gt;头部长度：指出TCP头部的长度，以4字节为单位。作为一个4位字段，TCP头部被限制为最大60字节；&lt;/li&gt;
&lt;li&gt;保留：4位，暂时没用，填充为0；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CWR&lt;/strong&gt;：1位，拥塞窗口减（发送方降低发送速率）；&lt;/li&gt;
&lt;li&gt;ECE：1位，ECN回显（发送方接收到了一个更早的拥塞通告）；&lt;/li&gt;
&lt;li&gt;URG：1位，紧急（使紧急指针字段有效）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ACK&lt;/strong&gt;：1位，确认（使确认号字段有效）；&lt;/li&gt;
&lt;li&gt;PSH：1位，推送（接收方应尽快给应用程序传送这个数据）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RST&lt;/strong&gt;：1位，重置连接；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SYN&lt;/strong&gt;：1位，用于初始化一个连接的同步序列号；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIN&lt;/strong&gt;：1位，该报文段的发送方已经结束向对方发送数据；&lt;/li&gt;
&lt;li&gt;窗口大小：窗口通告，以字节为单位通知对方更新窗口大小；&lt;/li&gt;
&lt;li&gt;TCP校验和：检测比特差错；&lt;/li&gt;
&lt;li&gt;紧急指针：用于发送紧急数据，参考《APUE》带外数据；&lt;/li&gt;
&lt;li&gt;选项：最常见的选项是MSS（最大端大小）；&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
